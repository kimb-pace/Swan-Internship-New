---
title: "Quadrat Frequency PERMANOVA Script, All Classes"
output: html_document
date: "2025-02-04"
---

READ FIRST: 

Adonis2, by default, calculates F statistics as term/residual. This is not necessarily the most exact test for significance (Anderson 2002), and the most exact test can be determined by deriving the expected mean squared variance for your specified model. The correct F calculation can be determined by assigning the variance associated with term of interest to the numerator and finding the term that accounts for all of the variance besides the specific term variance. 

This leads us to need to hand-calculate specific terms in our models by extracting the permutation sums of squares and recalculating the F and P values with the new values. 

For these specific models, we determined that the Park and Viereck.3 terms were more accurately calculated as Term/Plot rather than the Adonis2 default of Term/Residual. For the Viereck.3 F equation, there wasn't an exact test.  













# Setup 
```{r}
#test push
library(vegan)
library(permute)
library(lattice)
library(dplyr)
library(readxl)
library(readr)
library(writexl)
library(here)

#Required: 
    #Canopy Cover 
      #Load this file: 
      canopy_cover <- read_xlsx(here("Data/Modified/canopy_cover.xlsx")) 
      
      #How I calculated the percent cover column: 
      canopy_cover <- read_csv(here("Data/Unmodified/Canopy_Cover_PtInt.csv"))
      canopy_cover <- canopy_cover %>%
        mutate(Plot_Year = paste(Plot, Sample_Year, sep = "_")) %>%
        group_by(Plot_Year) %>%
        mutate(Percent_Cover = (sum(hits) / 177) * 100) %>% 
        ungroup()

#Optional (Can avoid if using quickload within subsets)

#If interested in how I balanced the subsets and built the .env files
summary_table_vasc <- read_xlsx(here("Data/Modified/summary_table_vasc.xlsx"))
summary_table_nonvasc <- read_xlsx(here("Data/Modified/summary_table_nonvasc.xlsx"))
summary_table_lichens <- read_xlsx(here("Data/Modified/summary_table_lichens.xlsx")) 
      
quad_abundance_df_vascular_filtered <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/quad_abundance_df_vascular_filtered.xlsx"))
quad_abundance_df_lichen_filtered <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/quad_abundance_df_lichen_filtered.xlsx"))
quad_abundance_df_nonvasc_filtered <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/quad_abundance_df_nonvasc_filtered.xlsx"))
      
lichen_sp_richness <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/lichen_sp_richness_filtered.xlsx"))
nonvasc_sp_richness <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/nonvasc_sp_richness_filtered.xlsx"))
vasc_sp_richness <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/vascular_sp_richness_filtered.xlsx"))
```

# Creation of Summary Tables, Code for Reference (not required to run if using quick load)
```{r}
#Vascular 
summary_table_vasc <- vasc_abundance_df  %>%
  group_by(Plot) %>%
  summarise(
    Number_Visits = n_distinct(Sample_Year), 
    Visit_Years = paste(sort(unique(Sample_Year)), collapse = ", "),
    Vegetation_Class = unique(Vegetation_Class))
summary_table_vasc <- summary_table_vasc %>% 
  arrange(Vegetation_Class, Number_Visits)
summary_table_vasc <- summary_table_vasc %>%
  left_join(vasc_abundance_df %>% select(Plot, Viereck.2, Viereck.3),
            by = "Plot")
summary_table_vasc <- summary_table_vasc %>% distinct()

#Lichens 
summary_table_lichens <- lichen_abundance_df  %>%
  group_by(Plot) %>%
  summarise(
    Number_Visits = n_distinct(Sample_Year), 
    Visit_Years = paste(sort(unique(Sample_Year)), collapse = ", "),
    Vegetation_Class = unique(Vegetation_Class))
summary_table_lichens <- summary_table_lichens %>% 
  arrange(Vegetation_Class, Number_Visits)
summary_table_lichens <- summary_table_lichens %>%
  left_join(lichen_abundance_df %>% select(Plot, Viereck.1, Viereck.2, Viereck.3),
            by = "Plot")
summary_table_lichens <- summary_table_lichens %>% distinct()

#Nonvascular 
summary_table_nonvasc <- nonvasc_abundance_df  %>%
  group_by(Plot) %>%
  summarise(
    Number_Visits = n_distinct(Sample_Year), 
    Visit_Years = paste(sort(unique(Sample_Year)), collapse = ", "),
    Vegetation_Class = unique(Vegetation_Class))
summary_table_nonvasc <- summary_table_lichens %>% 
  arrange(Vegetation_Class, Number_Visits)
summary_table_nonvasc <- summary_table_nonvasc %>%
  left_join(nonvasc_abundance_df %>% select(Plot, Viereck.1, Viereck.2, Viereck.3),
            by = "Plot")
summary_table_nonvasc <- summary_table_nonvasc %>% distinct()
```


# Beetle Disturbed Spruce 

## Building the dataframes to be balanced - code for reference (not required to run if using quick load)
```{r}
#Vascular 
    #hand select the years for plots with more than the decided number of visits 
      filter_criteria_beetle <- list(
        KATM_2009_01_S996 = c(2012, 2014, 2019),
        KATM_2009_01_S999 = c(2013, 2014, 2019),
        KATM_2009_01_S995 = c(2012, 2014, 2019),
        LACL_2010_01_S995	= c(2012, 2014, 2019))
      
      #next identify plots with three plot visits 
      beetle_plots <- summary_table_vasc %>%
        filter(Vegetation_Class == "Beetle kill spruce", Number_Visits == 3) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(beetle_plots, names(filter_criteria_beetle))
      
      #subset main presence absence dataframe based on both conditions 
      #verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
        filter(
          Plot %in% names(filter_criteria_beetle) & 
            Sample_Year %in% unlist(filter_criteria_beetle[Plot]))
      
      beetle_df <- quad_abundance_df_vascular_filtered %>%
        filter(
          (Plot %in% beetle_plots) | 
            (Plot %in% names(filter_criteria_beetle) &
               Sample_Year %in% unlist(filter_criteria_beetle[Plot])))
    
      #convert to frequency from PA 
      beetle_vasc_abundance_balanced <- vasc_abundance_df %>%
        filter(Plot_Year %in% beetle_df$Plot_Year)
      beetle_df <- beetle_vasc_abundance_balanced 

#Lichen 
  #hand select the years for plots with more than the decided number of visits
          filter_criteria_beetle_lichen <- list(
            KATM_2009_01_S996 = c(2012, 2014, 2019),
            KATM_2009_01_S999 = c(2013, 2014, 2019),
            KATM_2009_01_S995 = c(2012, 2014, 2019),
            LACL_2010_01_S995	= c(2012, 2014, 2019))
          
          #next identify plots with three plot visits 
          beetle_lichen_plots <- summary_table_lichens %>%
            filter(Vegetation_Class == "Beetle kill spruce", Number_Visits == 3) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(beetle_lichen_plots, names(filter_criteria_beetle_lichen))
          selected_plots
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_lichen_filtered %>%
            filter(
              Plot %in% names(filter_criteria_beetle_lichen) & 
                Sample_Year %in% unlist(filter_criteria_beetle_lichen[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          beetle_df_lichen <- quad_abundance_df_lichen_filtered %>%
            filter(
              (Plot %in% beetle_lichen_plots) | 
                (Plot %in% names(filter_criteria_beetle_lichen) &
                   Sample_Year %in% unlist(filter_criteria_beetle_lichen[Plot])))
          
          #verify everything has two sample visits 
          table(beetle_df_lichen$Park, beetle_df_lichen$Plot)
          
          #convert to frequency from PA 
          beetle_lichen_abundance_balanced <- lichen_abundance_df %>%
            filter(Plot_Year %in% beetle_lichen_df$Plot_Year)
          beetle_lichen_df <- beetle_lichen_abundance_balanced 

#Nonvascular 
  #hand select the years for plots with more than the decided number of visits
 filter_criteria_beetle_nonvasc <- list(
            KATM_2009_01_S996 = c(2012, 2014, 2019),
            KATM_2009_01_S999 = c(2013, 2014, 2019),
            KATM_2009_01_S995 = c(2012, 2014, 2019),
            LACL_2010_01_S995	= c(2012, 2014, 2019))
          
          #next identify plots with three plot visits 
          beetle_nonvasc_plots <- summary_table_nonvasc %>%
            filter(Vegetation_Class == "Beetle kill spruce", Number_Visits == 3) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(beetle_nonvasc_plots, names(filter_criteria_beetle_nonvasc))
          selected_plots
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              Plot %in% names(filter_criteria_beetle_nonvasc) & 
                Sample_Year %in% unlist(filter_criteria_beetle_nonvasc[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          beetle_df_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              (Plot %in% beetle_nonvasc_plots) | 
                (Plot %in% names(filter_criteria_beetle_nonvasc) &
                   Sample_Year %in% unlist(filter_criteria_beetle_nonvasc[Plot])))
          
          #verify everything has two sample visits 
          table(beetle_df_nonvasc$Park, beetle_df_nonvasc$Plot)
          
          #convert to frequency from PA
          beetle_nonvasc_abundance_balanced <- nonvasc_abundance_df %>%
            filter(Plot_Year %in% beetle_df_nonvasc$Plot_Year)
          beetle_df_nonvasc <- beetle_nonvasc_abundance_balanced
```

## Creating the env files, code for reference (not required to run if using quick load) 
```{r}
#Vascular
      beetle_env <- beetle_df[,c(1:6)]
      
      #adding visit 
      beetle_env <- beetle_env %>%
        arrange(Plot, Sample_Year) %>%
        group_by(Plot) %>%
        mutate(Visit = paste0("visit_", row_number())) %>%
        ungroup()
      #adding canopy cover 
      beetle_env <- beetle_env %>%
        left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
      beetle_env <- beetle_env %>% distinct()
      #adding species richness 
      beetle_env <- beetle_env %>%
        left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
      
#Lichen
          beetle_env_lichen <- beetle_df_lichen[,c(1:8)]
          
          #add visit column
          beetle_env_lichen <- beetle_env_lichen %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #add canopy cover column 
          beetle_env_lichen <- beetle_env_lichen %>%
            left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
          beetle_env_lichen <- beetle_env_lichen %>% distinct()
          #add species richness column 
          beetle_env_lichen <- beetle_env_lichen %>%
            left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          
#Nonvascular
          beetle_env_nonvasc <- beetle_df_nonvasc[,c(1:8)]
          
          #adding visit column 
          beetle_env_nonvasc <- beetle_env_nonvasc %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #adding canopy cover column 
          beetle_env_nonvasc <- beetle_env_nonvasc %>%
            left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
          beetle_env_nonvasc <- beetle_env_nonvasc %>% distinct()
          #add species richness column 
          beetle_env_nonvasc <- beetle_env_nonvasc %>%
            left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
```

## Load Data Frames (Required)
```{r}
#quick pull from T Drive 
#dataframes
beetle_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_df_vasc_filtered.xlsx"))
beetle_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_df_lichen_filtered.xlsx"))
beetle_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_df_nonvasc_filtered.xlsx"))

#built env files
beetle_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_env_vasc_filtered.xlsx"))
beetle_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_env_lichen_filtered.xlsx"))
beetle_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/beetle_env_nonvasc_filtered.xlsx"))

#make sure sample year is numeric 
beetle_env$Sample_Year <- as.numeric(beetle_env$Sample_Year)
beetle_env_lichen$Sample_Year <- as.numeric(beetle_env_lichen$Sample_Year)
beetle_env_nonvasc$Sample_Year <- as.numeric(beetle_env_nonvasc$Sample_Year) 
```

## Calculate Species Richness Averages and Standard Error (Optional)
```{r}
#beetle kill
        beetle_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        beetle_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        beetle_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        beetle_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        beetle_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        beetle_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
```


## Create composition matrices, and restrict permutations for PERMANOVA (Requried)
```{r}
#Vascular 
beetle_composition <- beetle_df[,c(8:261)]
beetle_composition <- as.matrix(beetle_composition) 

      #design permutation structure 
      #time 
      perm_design_beetle_time = how(
        plots = Plots(strata = beetle_env$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      #for the park model 
      perm_design_beetle = how(
        plots = Plots(strata = beetle_env$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)


#Lichen 
beetle_lichen_composition <- beetle_df_lichen[,c(10:167)]
beetle_lichen_composition <- as.matrix(beetle_lichen_composition) 

      #design permutation structure 
      #time 
      perm_design_beetle_lichen_time = how(
        plots = Plots(strata = beetle_env_lichen$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      #for the park model 
      perm_design_beetle_lichen = how(
        plots = Plots(strata = beetle_env_lichen$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)


#Nonvascular 
beetle_nonvasc_composition <- beetle_df_nonvasc[,c(10:210)]
beetle_nonvasc_composition <- as.matrix(beetle_nonvasc_composition) 

      #restrict permutations 
      #Time 
      perm_design_beetle_nonvasc_time = how(
        plots = Plots(strata = beetle_env_nonvasc$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      #for the park model 
      perm_design_beetle_nonvasc = how(
        plots = Plots(strata = beetle_env_nonvasc$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)

```

## Run PERMANOVA 
```{r}
#Vascular 

#Differences between parks 
    #univariate (Species richness)
      #Base model 
      beetle_univariate_vasc_park <- adonis2(beetle_env$Species_Richness ~ Park + Plot,
                                   data = beetle_env, 
                                   method = "euclidian",
                                   permutations = perm_design_beetle,
                                   by = "terms")
      print(beetle_univariate_vasc_park)
    
      
  #hand calculate corrected F values 
      
      #create permutation object 
      perms1 <- rbind(1:nrow(beetle_env),
                      shuffleSet(n = nrow(beetle_env), control = perm_design_beetle, nset = 999))
      
      #create object for SS from each permutation to be stored 
      results1 <- matrix(nrow = nrow(perms1), ncol = 4)
      colnames(results1) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms1)) {
        temp.data <- beetle_env[perms1[i, ], ]
        temp <- adonis2(beetle_env$Species_Richness ~ Park + Plot,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results1[i, ] <- t(temp$SumOfSqs)
      }
      
    #create F value column - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results1 <- results1 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/13))
      head1 <- head(results1)
      print.data.frame(head1)
    
      #calculate P value 
      with(results1, sum(F.Park >= F.Park[1]) / length(F.Park))

      
#Differences between subclasses
    #univariate (Species richness)
      #Base model 
      beetle_univariate_vasc_subclass <- adonis2(beetle_env$Species_Richness ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                                   data = beetle_env, 
                                   method = "euclidian",
                                   permutations = perm_design_beetle_time,
                                   by = "terms")
      print(beetle_univariate_vasc_subclass)
      
      #hand calculate corrected F values 
      #create permutation object 
      perms01 <- rbind(1:nrow(beetle_env),
                      shuffleSet(n = nrow(beetle_env), control = perm_design_beetle, nset = 999))
      
      #create object for SS from each permutation to be stored 
      results01 <- matrix(nrow = nrow(perms01), ncol = 7)
      colnames(results01) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                               "Viereck.3*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms01)) {
        temp.data <- beetle_env[perms01[i, ], ]
        temp <- adonis2(beetle_env$Species_Richness ~ Viereck.3 + Park + 
                                                  Plot + Sample_Year + Viereck.3*Sample_Year,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results01[i, ] <- t(temp$SumOfSqs)
      }
      
      
    #create F value column for park term  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results01 <- results01 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/12))
      head01 <- head(results01)
      print.data.frame(head01)
      #calculate P value 
      with(results01, sum(F.Park >= F.Park[1]) / length(F.Park))
    
    #create F value column for viereck term - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results01 <- results01 |>
        data.frame() |>
        mutate(F.Viereck = (Viereck.3/1)/(Plot/12))
      head001 <- head(results01)
      print.data.frame(head001)
      #calculate P value 
      with(results01, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
      
#Multivariate (species frequency)
  #differences between parks 
      beetle_multivariate_vasc_park <- adonis2(beetle_composition ~ Park + Plot, 
                               data = beetle_env, method = "bray", 
                               permutations = perm_design_beetle, 
                               by = "terms")
      
      print(beetle_multivariate_vasc_park)
    #hand calculate corrected F values
      #create permutation object and results object for sums of squares to be stored 
      perms2 <- rbind(1:nrow(beetle_composition),
                      shuffleSet(n = nrow(beetle_composition), control = perm_design_beetle, nset = 999))
      results2 <- matrix(nrow = nrow(perms2), ncol = 4)
      colnames(results2) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms2)) {
        temp.data <- beetle_env[perms2[i, ], ]
        temp <- adonis2(beetle_composition ~ Park + Plot,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results2[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results2 <- results2 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/13))
      head2 <- head(results2)
      print.data.frame(head2)
      #calculate P value 
      with(results2, sum(F.Park >= F.Park[1]) / length(F.Park))

  #differences between subclasses
      beetle_multivariate_vasc_subclass <- adonis2(beetle_composition ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year, 
                               data = beetle_env, method = "bray", 
                               permutations = perm_design_beetle_time, 
                               by = "terms")
      
      print(beetle_multivariate_vasc_subclass)
      #hand calculate corrected F values
      #create permutation object  
      perms02 <- rbind(1:nrow(beetle_composition),
                      shuffleSet(n = nrow(beetle_composition), control = perm_design_beetle, nset = 999))
      #create object for SS from each permutation to be stored
      results02 <- matrix(nrow = nrow(perms02), ncol = 7)
      colnames(results02) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                               "Viereck.3*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms02)) {
        temp.data <- beetle_env[perms02[i, ], ]
        temp <- adonis2(beetle_composition ~ Viereck.3 + Park + 
                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results02[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistic for park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results02 <- results02 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/12))
      head02 <- head(results02)
      print.data.frame(head02)
      #calculate P value 
      with(results02, sum(F.Park >= F.Park[1]) / length(F.Park))
      
      
      #calculate F for viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results02 <- results02 |>
        data.frame() |>
        mutate(F.Viereck = (Viereck.3/1)/(Plot/12))
      head002 <- head(results02)
      print.data.frame(head002)
      #calculate P value 
      with(results02, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
     
      
#canopy cover effects 
    #Species richness 
        beetle_CC_univariate <- adonis2(beetle_env$Species_Richness ~ Percent_Cover + Park + Plot + Sample_Year, 
                                        data = beetle_env, method = "bray", 
                                        permutations = perm_design_beetle_time, 
                                        by = "terms")
        print(beetle_CC_univariate)

    #Species frequency 
        beetle_CC_multivariate <- adonis2(beetle_composition ~ Percent_Cover + Park + Plot + Sample_Year, 
                                          data = beetle_env, method = "bray", 
                                          permutations = perm_design_beetle_time, 
                                          by = "terms")
        print(beetle_CC_multivariate) 
      

### Beta Dispersion  
      #based on visit 
          beetle_dispersion_result1 <- betadisper(vegdist(beetle_composition, 
                                                          method = "bray"), beetle_env$Visit)
          beetle_dispersion_result1 
          permutest(beetle_dispersion_result1, permutations = 999)
      
      #based on park 
          beetle_dispersion_result2 <- betadisper(vegdist(beetle_composition, 
                                                          method = "bray"), beetle_env$Park)
          beetle_dispersion_result2 
          permutest(beetle_dispersion_result2, permutations = 999)
          
      #based on subclass
          beetle_dispersion_result3 <- betadisper(vegdist(beetle_composition, 
                                                          method = "bray"), beetle_env$Viereck.3)
          beetle_dispersion_result3 
          permutest(beetle_dispersion_result3, permutations = 999)
          
----------------------------------------------------------------------------------------------------------------           
#Lichen 
    #Differences between parks 
          #Species richness (univariate)
          #base model 
          beetle_univariate_lichen_park <- adonis2(beetle_env_lichen$Species_Richness ~ Park + Plot,
                                       data = beetle_env_lichen, 
                                       method = "euclidian",
                                       permutations = perm_design_beetle_lichen,
                                       by = "terms")
          print(beetle_univariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms3 <- rbind(1:nrow(beetle_env_lichen),
                          shuffleSet(n = nrow(beetle_env_lichen), control = perm_design_beetle_lichen, nset = 999))
          
          #create object for SS from each permutation to be stored
          results3 <- matrix(nrow = nrow(perms3), ncol = 4)
          colnames(results3) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms3)) {
            temp.data <- beetle_env_lichen[perms3[i, ], ]
            temp <- adonis2(beetle_env_lichen$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results3[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results3 <- results3 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head3 <- head(results3)
          print.data.frame(head3)
          #calculate P value 
          with(results3, sum(F.Park >= F.Park[1]) / length(F.Park))

    #Differences between subclasses 
          #Species richness (univariate)
          #base model 
          beetle_univariate_lichen_subclass <- adonis2(beetle_env_lichen$Species_Richness ~ Viereck.3 + Park + 
                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                                       data = beetle_env_lichen, 
                                       method = "euclidian",
                                       permutations = perm_design_beetle_lichen_time,
                                       by = "terms")
          print(beetle_univariate_lichen_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms03 <- rbind(1:nrow(beetle_env_lichen),
                          shuffleSet(n = nrow(beetle_env_lichen), 
                                     control = perm_design_beetle_lichen, nset = 999))
          
          #create object for SS from each permutation to be stored 
          results03 <- matrix(nrow = nrow(perms03), ncol = 7)
          colnames(results03) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                   "Viereck.3*Sample_Year", "Residual", "Total")
          
          #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe           
          
          for (i in 1:nrow(perms03)) {
            temp.data <- beetle_env_lichen[perms03[i, ], ]
            temp <- adonis2(beetle_env_lichen$Species_Richness ~ Viereck.3 + Park + 
                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results03[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column for park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results03 <- results03 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/11))
          head03 <- head(results03)
          print.data.frame(head03)
          #calculate P value 
          with(results03, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #create F value column for viereck class - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results03 <- results03 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/11))
          head03 <- head(results03)
          print.data.frame(head03)
          #calculate P value 
          with(results03, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))        
          

#multivariate (Species Frequency)
          
    #differences between parks 
          beetle_multivariate_lichen_park <- adonis2(beetle_lichen_composition ~ Park + Plot, 
                                   data = beetle_env_lichen, method = "bray", 
                                   permutations = perm_design_beetle_lichen, 
                                   by = "terms")
          print(beetle_multivariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation object  
          perms4 <- rbind(1:nrow(beetle_lichen_composition),
                          shuffleSet(n = nrow(beetle_lichen_composition), 
                                     control = perm_design_beetle_lichen, nset = 999))
          #create object for SS from each permutation to be stored
          results4 <- matrix(nrow = nrow(perms4), ncol = 4)
          colnames(results4) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms4)) {
            temp.data <- beetle_env_lichen[perms4[i, ], ]
            temp <- adonis2(beetle_lichen_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results4[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results4 <- results4 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head4 <- head(results4)
          print.data.frame(head4)
          #calculate P value 
          with(results4, sum(F.Park >= F.Park[1]) / length(F.Park))
 
          
      #differences between subclasses 
          beetle_multivariate_lichen_subclass <- adonis2(beetle_lichen_composition ~ Viereck.3 + Park + 
                                            Plot + Sample_Year + Viereck.3*Sample_Year, 
                                   data = beetle_env_lichen, method = "bray", 
                                   permutations = perm_design_beetle_lichen_time, 
                                   by = "terms")
          print(beetle_multivariate_lichen_subclass)
          
          #hand calculate corrected F values:
          #create permutation object 
          perms04 <- rbind(1:nrow(beetle_lichen_composition),
                          shuffleSet(n = nrow(beetle_lichen_composition), 
                                     control = perm_design_beetle_lichen, nset = 999))
          #create object for SS from each permutation to be stored
          results04 <- matrix(nrow = nrow(perms04), ncol = 7)
          colnames(results04) <- c("Viereck.3", "Park", "Plot", 
                                   "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms04)) {
            temp.data <- beetle_env_lichen[perms04[i, ], ]
            temp <- adonis2(beetle_lichen_composition ~ Viereck.3 + Park + 
                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results04[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistic for park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results04 <- results04 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/11))
          head04 <- head(results04)
          print.data.frame(head04)
          #calculate P value 
          with(results04, sum(F.Park >= F.Park[1]) / length(F.Park))
          
           #calculate F statistic for subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results04 <- results04 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/11))
          head04 <- head(results04)
          print.data.frame(head04)
          #calculate P value 
          with(results04, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
#canopy cover effects
    #Species Richness 
        beetle_CC_univariate_lichen <- adonis2(beetle_env_lichen$Species_Richness ~ 
                                                 Percent_Cover + Park + Plot + Sample_Year, 
                                                 data = beetle_env_lichen, method = "bray", 
                                                 permutations = perm_design_beetle_lichen_time, 
                                                 by = "terms")
        print(beetle_CC_univariate_lichen)   
        
    #Species Frequency 
        beetle_CC_multivariate_lichen <- adonis2(beetle_lichen_composition ~ 
                                                   Percent_Cover + Park + Plot + Sample_Year, 
                                                 data = beetle_env_lichen, method = "bray", 
                                                 permutations = perm_design_beetle_lichen_time, 
                                                 by = "terms")
        print(beetle_CC_multivariate_lichen) 
          

### Beta Diversity 

      #based on visit 
      beetle_dispersion_result1_lichen <- betadisper(vegdist(beetle_lichen_composition, 
                                                      method = "bray"), beetle_env_lichen$Visit)
      beetle_dispersion_result1_lichen 
      permutest(beetle_dispersion_result1_lichen, permutations = 999)
      
      #based on subclass
      beetle_dispersion_result2_lichen <- betadisper(vegdist(beetle_lichen_composition, 
                                                      method = "bray"), beetle_env_lichen$Viereck.3)
      beetle_dispersion_result2_lichen 
      permutest(beetle_dispersion_result2_lichen, permutations = 999)

----------------------------------------------------------------------------------------------------------------        
#Nonvascular 
    #Species richness (Univariate)
    #Differences between parks 
          #base park model 
          beetle_univariate_nonvasc_park <- adonis2(beetle_env_nonvasc$Species_Richness ~ Park + Plot,
                                       data = beetle_env_nonvasc, 
                                       method = "euclidian",
                                       permutations = perm_design_beetle_nonvasc,
                                       by = "terms")
          print(beetle_univariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms5 <- rbind(1:nrow(beetle_env_nonvasc),
                          shuffleSet(n = nrow(beetle_env_nonvasc), 
                                     control = perm_design_beetle_nonvasc, nset = 999))
          
          #create object for SS from each permutation to be stored 
          results5 <- matrix(nrow = nrow(perms5), ncol = 4)
          colnames(results5) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms5)) {
            temp.data <- beetle_env_nonvasc[perms5[i, ], ]
            temp <- adonis2(beetle_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results5[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results5 <- results5 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head5 <- head(results5)
          print.data.frame(head5)
          #calculate P value 
          with(results5, sum(F.Park >= F.Park[1]) / length(F.Park))


  #Differences between subclasses 
          #base model 
          beetle_univariate_nonvasc_subclass <- adonis2(beetle_env_nonvasc$Species_Richness ~ Viereck.3 + 
                                                          Park + Plot + Sample_Year + Viereck.3*Sample_Year,
                                       data = beetle_env_nonvasc, 
                                       method = "euclidian",
                                       permutations = perm_design_beetle_nonvasc_time,
                                       by = "terms")
          print(beetle_univariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms05 <- rbind(1:nrow(beetle_env_nonvasc),
                          shuffleSet(n = nrow(beetle_env_nonvasc), 
                                     control = perm_design_beetle_nonvasc, nset = 999))
          
          #create object for SS from each permutation to be stored 
          results05 <- matrix(nrow = nrow(perms05), ncol = 7)
          colnames(results05) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                   "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms05)) {
            temp.data <- beetle_env_nonvasc[perms05[i, ], ]
            temp <- adonis2(beetle_env_nonvasc$Species_Richness ~ Viereck.3 + Park + Plot + 
                                             Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results05[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results05 <- results05 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/11))
          head05 <- head(results05)
          print.data.frame(head05)
          #calculate P value 
          with(results05, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results05 <- results05 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/11))
          head05 <- head(results05)
          print.data.frame(head05)
          #calculate P value 
          with(results05, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
#Multivariate - Species Frequency 
          
      #differences between parks 
          #base model 
          beetle_multivariate_nonvasc_park <- adonis2(beetle_nonvasc_composition ~ Park + Plot, 
                                   data = beetle_env_nonvasc, method = "bray", 
                                   permutations = perm_design_beetle_nonvasc, 
                                   by = "terms")
          print(beetle_multivariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms6 <- rbind(1:nrow(beetle_nonvasc_composition),
                          shuffleSet(n = nrow(beetle_nonvasc_composition), 
                                     control = perm_design_beetle_nonvasc, nset = 999))
          #create object for SS from each permutation to be stored
          results6 <- matrix(nrow = nrow(perms6), ncol = 4)
          colnames(results6) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms6)) {
            temp.data <- beetle_env_nonvasc[perms6[i, ], ]
            temp <- adonis2(beetle_nonvasc_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results6[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results6 <- results6 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head6 <- head(results6)
          print.data.frame(head6)
          #calculate P value 
          with(results6, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  #differences between subclasses 
          #base model 
          beetle_multivariate_nonvasc_subclass <- adonis2(beetle_nonvasc_composition ~ Viereck.3 + Park + Plot + 
                                             Sample_Year + Viereck.3*Sample_Year, 
                                   data = beetle_env_nonvasc, method = "bray", 
                                   permutations = perm_design_beetle_nonvasc_time, 
                                   by = "terms")
          print(beetle_multivariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms06 <- rbind(1:nrow(beetle_nonvasc_composition),
                          shuffleSet(n = nrow(beetle_nonvasc_composition), 
                                     control = perm_design_beetle_nonvasc, nset = 999))
          #create object for SS from each permutation to be stored
          results06 <- matrix(nrow = nrow(perms06), ncol = 7)
          colnames(results06) <- c("Viereck.3", "Park", "Plot", 
                                   "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms06)) {
            temp.data <- beetle_env_nonvasc[perms06[i, ], ]
            temp <- adonis2(beetle_nonvasc_composition ~ Viereck.3 + Park + Plot + 
                                             Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results06[i, ] <- t(temp$SumOfSqs)
          }
          
      #calculate F statistics for each permutation using corrected equation 
          #park - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results06 <- results06 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/11))
          head06 <- head(results06)
          print.data.frame(head06)
          #calculate P value 
          with(results06, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #calculate F statistics for viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results06 <- results06 |>
            data.frame() |>
            mutate(F.Viereck= (Viereck.3/1)/(Plot/11))
          head06 <- head(results06)
          print.data.frame(head06)
          #calculate P value 
          with(results06, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
  

#canopy cover effects 
      #Species Richness 
        beetle_CC_univariate_nonvasc <- adonis2(beetle_env_nonvasc$Species_Richness ~ 
                                                  Percent_Cover + Park + Plot + Sample_Year, 
                                     data = beetle_env_nonvasc, method = "bray", 
                                     permutations = perm_design_beetle_nonvasc_time, 
                                     by = "terms")
        print(beetle_CC_univariate_nonvasc)         
      #Species Frequency 
        beetle_CC_multivariate_nonvasc <- adonis2(beetle_nonvasc_composition ~ 
                                                    Percent_Cover + Park + Plot + Sample_Year, 
                                     data = beetle_env_nonvasc, method = "bray", 
                                     permutations = perm_design_beetle_nonvasc_time, 
                                     by = "terms")
        print(beetle_CC_multivariate_nonvasc) 
          
#beta dispersion 
        #based on visit 
          beetle_dispersion_result1_nonvasc <- betadisper(vegdist(beetle_nonvasc_composition, 
                                                          method = "bray"), beetle_env_nonvasc$Visit)
          beetle_dispersion_result1_nonvasc
          permutest(beetle_dispersion_result1_nonvasc, permutations = 999)
          
        #based on subclass
          beetle_dispersion_result2_nonvasc <- betadisper(vegdist(beetle_nonvasc_composition, 
                                                                 method = "bray"), beetle_env_nonvasc$Viereck.3)
          beetle_dispersion_result2_nonvasc 
          permutest(beetle_dispersion_result2_nonvasc, permutations = 999)

```



# Spruce Woodland 

## Building the Dataframes to be balanced - Code for reference (not required to run if using quick load)
```{r}
#Vascular 
    #hand select the years for plots with more than the decided number of visits
  filter_criteria_needle <- list(
            KATM_2009_01_S002 = c(2014, 2021),
            KATM_2009_01_S012 = c(2015, 2021),
            KATM_2009_01_S027 = c(2015, 2021),
            KATM_2009_01_S035 = c(2015, 2019),
            KATM_2009_01_S038 = c(2014, 2019),
            KATM_2009_01_S050 = c(2017, 2021), 
            KATM_2012_01_S041 = c(2014, 2019),
            KATM_2012_01_S190 = c(2015, 2021),
            LACL_2010_01_009 = c(2015, 2021),
            LACL_2010_01_105 = c(2015, 2022),
            LACL_2010_02_005 = c(2015, 2022),
            LACL_2010_02_092 = c(2015, 2022),  
            LACL_2010_02_S998 = c(2016, 2022),
            LACL_2012_01_162 = c(2015, 2022),
            LACL_2007_02_005 = c(2017, 2022),
            LACL_2008_02_048 = c(2015, 2022),
            LACL_2010_01_024 = c(2015, 2021),
            LACL_2010_01_030 = c(2015, 2022),  
            LACL_2010_01_S994 = c(2015, 2021),
            LACL_2008_02_014 = c(2015, 2021)
          )
          
          #next identify plots with two plot visits 
          needle_plots <- summary_table_vasc %>%
            filter(Viereck.3 == "Woodland Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(needle_plots, names(filter_criteria_needle))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
            filter(
              Plot %in% names(filter_criteria_needle) & 
                Sample_Year %in% unlist(filter_criteria_needle[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          needle_df <- quad_abundance_df_vascular_filtered %>%
            filter(
              (Plot %in% needle_plots) | 
                (Plot %in% names(filter_criteria_needle) &
                   Sample_Year %in% unlist(filter_criteria_needle[Plot])))
          
          #verify everything has two sample visits 
          table(needle_df$Park, needle_df$Plot)
          
          #convert to frequency from PA
          needle_vasc_abundance_balanced <- vasc_abundance_df %>%
            filter(Plot_Year %in% needle_df$Plot_Year)
          needle_df <- needle_vasc_abundance_balanced 

#lichen 
    #hand select the years for plots with more than the decided number of visits
          filter_criteria_needle_lichen <- list(
            KATM_2009_01_S002	= c(2014, 2021),
            KATM_2009_01_S012	= c(2015, 2021),
            KATM_2009_01_S027	= c(2015, 2021),
            KATM_2009_01_S035	= c(2015, 2019),
            KATM_2009_01_S038	= c(2014, 2019),
            KATM_2009_01_S050	= c(2017, 2021),
            KATM_2012_01_S041	= c(2014, 2019),
            KATM_2012_01_S190	= c(2015, 2021),
            LACL_2008_02_014	= c(2012, 2021),
            LACL_2008_02_048	= c(2015, 2022),
            LACL_2010_01_009	= c(2015, 2021),
            LACL_2010_01_030	= c(2015, 2022),
            LACL_2010_01_105	= c(2015, 2022),
            LACL_2010_02_005	= c(2015, 2022),
            LACL_2010_02_092	= c(2015, 2022),
            LACL_2010_02_S998	= c(2016, 2022),
            LACL_2010_01_024	= c(2015, 2021),
            LACL_2010_01_S994	= c(2015, 2021))
          
          #next identify plots with two plot visits 
          needle_plots_lichen <- summary_table_lichens %>%
            filter(Viereck.3 == "Woodland Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(needle_plots_lichen, names(filter_criteria_needle_lichen))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_lichen_filtered %>%
            filter(
              Plot %in% names(filter_criteria_needle_lichen) & 
                Sample_Year %in% unlist(filter_criteria_needle_lichen[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          needle_df_lichen <- quad_abundance_df_lichen_filtered %>%
            filter(
              (Plot %in% needle_plots_lichen) | 
                (Plot %in% names(filter_criteria_needle_lichen) &
                   Sample_Year %in% unlist(filter_criteria_needle_lichen[Plot])))
          
          #verify everything has two sample visits 
          table(needle_df_lichen$Park, needle_df_lichen$Plot)
          
          needle_df_lichen <- needle_df_lichen[-15, ]
          needle_df_lichen <- needle_df_lichen[-18, ]
          needle_df_lichen <- needle_df_lichen[-39, ]
          
          #convert to frequency from PA
          needle_lichen_abundance_balanced <- lichen_abundance_df %>%
            filter(Plot_Year %in% needle_df_lichen$Plot_Year)
          needle_lichen_df <- needle_lichen_abundance_balanced 
          
#nonvascular 
      #hand select the years for plots with more than the decided number of visits
          filter_criteria_needle_nonvasc <- list(
            KATM_2009_01_S002	= c(2014, 2021),
            KATM_2009_01_S012	= c(2015, 2021),
            KATM_2009_01_S027	= c(2015, 2021),
            KATM_2009_01_S035	= c(2015, 2019),
            KATM_2009_01_S038	= c(2014, 2019),
            KATM_2009_01_S050	= c(2017, 2021),
            KATM_2012_01_S041	= c(2014, 2019),
            KATM_2012_01_S190	= c(2015, 2021),
            LACL_2008_02_014	= c(2012, 2021),
            LACL_2008_02_048	= c(2015, 2022),
            LACL_2010_01_009	= c(2015, 2021),
            LACL_2010_01_030	= c(2015, 2022),
            LACL_2010_01_105	= c(2015, 2022),
            LACL_2010_02_005	= c(2015, 2022),
            LACL_2010_02_092	= c(2015, 2022),
            LACL_2010_02_S998	= c(2016, 2022),
            LACL_2010_01_024	= c(2015, 2021),
            LACL_2010_01_S994	= c(2015, 2021))
          
          #next identify plots with two plot visits 
          needle_plots_nonvasc <- summary_table_nonvasc %>%
            filter(Viereck.3 == "Woodland Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(needle_plots_nonvasc, names(filter_criteria_needle_nonvasc))
          
          #lichenspresence_absence_df <- lichenspresence_absence_df %>%
          # left_join(viereck %>% select(Plot_Year, Viereck.3), by = c("Plot_Year"))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              Plot %in% names(filter_criteria_needle_nonvasc) & 
                Sample_Year %in% unlist(filter_criteria_needle_nonvasc[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          needle_df_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              (Plot %in% needle_plots_nonvasc) | 
                (Plot %in% names(filter_criteria_needle_nonvasc) &
                   Sample_Year %in% unlist(filter_criteria_needle_nonvasc[Plot])))
          
          #verify everything has two sample visits 
          table(needle_df_nonvasc$Park, needle_df_nonvasc$Plot)
          
          needle_df_nonvasc <- needle_df_nonvasc[-41, ]
          needle_df_nonvasc <- needle_df_nonvasc[-18, ]
          needle_df_nonvasc <- needle_df_nonvasc[-15, ]
          
          #convert to frequency from PA
          needle_nonvasc_abundance_balanced <- nonvasc_abundance_df %>%
            filter(Plot_Year %in% needle_df_nonvasc$Plot_Year)
          needle_nonvasc_df <- needle_nonvasc_abundance_balanced
```

## Creating the env files, code for reference (not required to run if using quick load)
```{r}
#Vascular
          needle_env <- needle_df[,c(1:6)]
          
          #add visit column 
          needle_env <- needle_env %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #add species richness column
          needle_env <- needle_env %>%
            left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          
#lichen

          needle_env_lichen <- needle_df_lichen[,c(1:8)]
          
          #add visit column
          needle_env_lichen <- needle_env_lichen %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #add species richness 
          needle_env_lichen <- needle_env_lichen %>%
            left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          

#nonvascular 

          needle_env_nonvasc <- needle_df_nonvasc[,c(1:8)]
          
          #add visit column
          needle_env_nonvasc <- needle_env_nonvasc %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #Add species richness column 
          needle_env_nonvasc <- needle_env_nonvasc %>%
            left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))

```

## Load data frames (Required)
```{r}
#Quick load of dataframes from T drive
needle_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_df_vasc_filtered.xlsx"))
needle_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_df_lichen_filtered.xlsx"))
needle_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_df_nonvasc_filtered.xlsx"))
    
needle_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_env_vasc_filtered.xlsx"))
needle_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_env_lichen_filtered.xlsx"))
needle_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/needle_env_nonvasc_filtered.xlsx"))

#ensuring that sample year is numeric 
    needle_env$Sample_Year <- as.numeric(needle_env$Sample_Year)
    needle_env_lichen$Sample_Year <- as.numeric(needle_env_lichen$Sample_Year)
    needle_env_nonvasc$Sample_Year <- as.numeric(needle_env_nonvasc$Sample_Year) 

```

## Calculate Species Richness Averages and Standard Error (Optional)
```{r}
#Spruce Woodlands 
        needle_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        needle_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        needle_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        needle_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        needle_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        needle_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))

```

## Create composition matrices, and restrict permutations for PERMANOVA (Required)
```{r}
#Vascular 
          needle_composition <- needle_df[,c(8:261)]
          needle_composition <- as.matrix(needle_composition) 
          
          #design permutation structure 
          perm_design_needle = how(
            plots = Plots(strata = needle_env$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)
          perm_design_needle_time = how(
            plots = Plots(strata = needle_env$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)

#Lichen 
          needle_composition_lichen <- needle_df_lichen[,c(10:167)]
          needle_composition_lichen <- as.matrix(needle_composition_lichen) 
          
          #design permutation structure 
          perm_design_needle_lichen = how(
            plots = Plots(strata = needle_env_lichen$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)
          perm_design_needle_time_lichen = how(
            plots = Plots(strata = needle_env_lichen$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          

#Nonvascular 
          needle_composition_nonvasc <- needle_df_nonvasc[,c(10:210)]
          needle_composition_nonvasc <- as.matrix(needle_composition_nonvasc) 
          
          #design permutation structure 
          perm_design_needle_nonvasc = how(
            plots = Plots(strata = needle_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)
          perm_design_needle_time_nonvasc = how(
            plots = Plots(strata = needle_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
```


## Run PERMANOVA 
```{r}
#Vascular 

  #Species Richness (Univariate)
    #Differences between parks 
          #base model 
          needle_univariate_vascular_park <- adonis2(needle_env$Species_Richness ~ Park + Plot,
                                       data = needle_env, 
                                       method = "euclidian",
                                       permutations = perm_design_needle,
                                       by = "terms")
          print(needle_univariate_vascular_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms7 <- rbind(1:nrow(needle_env),
                           shuffleSet(n = nrow(needle_env), control = perm_design_needle, nset = 999))
          
          #create object for SS to be stored 
          results7 <- matrix(nrow = nrow(perms7), ncol = 4)
          colnames(results7) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms7)) {
            temp.data <- needle_env[perms7[i, ], ]
            temp <- adonis2(needle_env$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results7[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results7 <- results7 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/28))
          head7 <- head(results7)
          print.data.frame(head7)
          #calculate P value 
          with(results7, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  #Differences between through time  
          #base model 
          needle_univariate_vascular_time <- adonis2(needle_env$Species_Richness ~ Park + Plot + 
                                                       Sample_Year + Park*Sample_Year,
                                       data = needle_env, 
                                       method = "euclidian",
                                       permutations = perm_design_needle_time,
                                       by = "terms")
          print(needle_univariate_vascular_time)
          
          #create permutation object 
          perms07 <- rbind(1:nrow(needle_env),
                           shuffleSet(n = nrow(needle_env), control = perm_design_needle, nset = 999))
          
      #hand calculate corrected F values
          #create object for SS to be stored 
          results07 <- matrix(nrow = nrow(perms07), ncol = 6)
          colnames(results07) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms07)) {
            temp.data <- needle_env[perms07[i, ], ]
            temp <- adonis2(needle_env$Species_Richness ~ Park + Plot + Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results07[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results07 <- results07 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/28))
          head07 <- head(results07)
          print.data.frame(head07)
          #calculate P value 
          with(results07, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  ### Multivariate - species frequency
      #differences between parks 
          #base model 
          needle_multivariate_vascular_park <- adonis2(needle_composition ~ Park + Plot, 
                                   data = needle_env, method = "bray", 
                                   permutations = perm_design_needle, 
                                   by = "terms")
          print(needle_multivariate_vascular_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms8 <- rbind(1:nrow(needle_composition),
                           shuffleSet(n = nrow(needle_composition), 
                                      control = perm_design_needle, nset = 999))
          results8 <- matrix(nrow = nrow(perms8), ncol = 4)
          colnames(results8) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms8)) {
            temp.data <- needle_env[perms8[i, ], ]
            temp <- adonis2(needle_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results8[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results8 <- results8 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/28))
          head8 <- head(results8)
          print.data.frame(head8)
          #calculate P value 
          with(results8, sum(F.Park >= F.Park[1]) / length(F.Park))

      #differences through time 
          #base model 
          needle_multivariate_vascular_time <- adonis2(needle_composition ~ Park + Plot + 
                                                         Sample_Year + Park*Sample_Year, 
                                   data = needle_env, method = "bray", 
                                   permutations = perm_design_needle_time, 
                                   by = "terms")
          print(needle_multivariate_vascular_time)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms08 <- rbind(1:nrow(needle_composition),
                           shuffleSet(n = nrow(needle_composition), 
                                      control = perm_design_needle, nset = 999))
          results08 <- matrix(nrow = nrow(perms08), ncol = 6)
          colnames(results08) <- c("Park", "Plot", "Sample_Year", 
                                   "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms08)) {
            temp.data <- needle_env[perms08[i, ], ]
            temp <- adonis2(needle_composition ~ Park + Plot + Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results08[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results08 <- results08 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/28))
          head08 <- head(results08)
          print.data.frame(head08)
          #calculate P value 
          with(results08, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  #beta diversity 
          
        #based on park 
          needle_dispersion_result <- betadisper(vegdist(needle_composition, 
                                                         method = "bray"), needle_env$Park)
          needle_dispersion_result 
          permutest(needle_dispersion_result, permutations = 999)
          
        #based on visit 
          needle_dispersion_result2 <- betadisper(vegdist(needle_composition, 
                                                          method = "bray"), needle_env$Visit)
          needle_dispersion_result2 
          permutest(needle_dispersion_result2, permutations = 999)
----------------------------------------------------------------------------------------------------------------
#Lichen 
          
  #Species Richness (Univariate) 
    #Differences between parks 
          #base model 
          needle_univariate_lichen_park <- adonis2(needle_env_lichen$Species_Richness ~ Park + Plot,
                                              data = needle_env_lichen, 
                                              method = "euclidian",
                                              permutations = perm_design_needle_lichen,
                                              by = "terms")
          print(needle_univariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms9 <- rbind(1:nrow(needle_env_lichen),
                           shuffleSet(n = nrow(needle_env_lichen), 
                                      control = perm_design_needle_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results9 <- matrix(nrow = nrow(perms9), ncol = 4)
          colnames(results9) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms9)) {
            temp.data <- needle_env_lichen[perms9[i, ], ]
            temp <- adonis2(needle_env_lichen$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results9[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results9 <- results9 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head9 <- head(results9)
          print.data.frame(head9)
          #calculate P value 
          with(results9, sum(F.Park >= F.Park[1]) / length(F.Park))

            
    #Differences through time 
          #base model 
          needle_univariate_lichen_time <- adonis2(needle_env_lichen$Species_Richness ~ Park + Plot + 
                                                     Sample_Year + Park*Sample_Year,
                                              data = needle_env_lichen, 
                                              method = "euclidian",
                                              permutations = perm_design_needle_time_lichen,
                                              by = "terms")
          print(needle_univariate_lichen_time)
          
          #hand calculate corrected F values
          #create permutation object 
          perms09 <- rbind(1:nrow(needle_env_lichen),
                           shuffleSet(n = nrow(needle_env_lichen), 
                                      control = perm_design_needle_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results09 <- matrix(nrow = nrow(perms09), ncol = 6)
          colnames(results09) <- c("Park", "Plot", "Sample_Year",
                                   "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms09)) {
            temp.data <- needle_env_lichen[perms09[i, ], ]
            temp <- adonis2(needle_env_lichen$Species_Richness ~ Park + Plot + 
                              Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results09[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results09 <- results09 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head09 <- head(results09)
          print.data.frame(head09)
          
          #calculate P value 
          with(results09, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  
### Multivariate (Species Frequency)
      #differences between parks 
          #base model 
          needle_multivariate_lichen_park <- adonis2(needle_composition_lichen ~ Park + Plot, 
                                          data = needle_env_lichen, method = "bray", 
                                          permutations = perm_design_needle_lichen, 
                                          by = "terms")
          print(needle_multivariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms10 <- rbind(1:nrow(needle_composition_lichen),
                           shuffleSet(n = nrow(needle_composition_lichen), 
                                      control = perm_design_needle_lichen, nset = 999))
          results10 <- matrix(nrow = nrow(perms10), ncol = 4)
          colnames(results10) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms10)) {
            temp.data <- needle_env_lichen[perms10[i, ], ]
            temp <- adonis2(needle_composition_lichen ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results10[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results10 <- results10 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head10 <- head(results10)
          print.data.frame(head10)
          #calculate P value 
          with(results10, sum(F.Park >= F.Park[1]) / length(F.Park))
  
      #differences through time 
          #base model 
          needle_multivariate_lichen_time <- adonis2(needle_composition_lichen ~ Park + Plot + 
                                                       Sample_Year + Park*Sample_Year, 
                                          data = needle_env_lichen, method = "bray", 
                                          permutations = perm_design_needle_time_lichen, 
                                          by = "terms")
          print(needle_multivariate_lichen_time)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms010 <- rbind(1:nrow(needle_composition_lichen),
                           shuffleSet(n = nrow(needle_composition_lichen), 
                                      control = perm_design_needle_lichen, nset = 999))
          results010 <- matrix(nrow = nrow(perms010), ncol = 6)
          colnames(results010) <- c("Park", "Plot", "Sample_Year", 
                                    "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms010)) {
            temp.data <- needle_env_lichen[perms010[i, ], ]
            temp <- adonis2(needle_composition_lichen ~ Park + Plot + Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results010[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results010 <- results010 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head010 <- head(results010)
          print.data.frame(head010)
          #calculate P value 
          with(results010, sum(F.Park >= F.Park[1]) / length(F.Park))
          
  #beta diversity 
          
      #based on park 
          needle_dispersion_result_lichen <- betadisper(vegdist(needle_composition_lichen, 
                                                                method = "bray"), needle_env_lichen$Park)
          needle_dispersion_result_lichen 
          permutest(needle_dispersion_result_lichen, permutations = 999)
          
      #based on visit 
          needle_dispersion_result2_lichen <- betadisper(vegdist(needle_composition_lichen, 
                                                                 method = "bray"), needle_env_lichen$Visit)
          needle_dispersion_result2_lichen
          permutest(needle_dispersion_result2_lichen, permutations = 999)
          
----------------------------------------------------------------------------------------------------------------
#Nonvascular 
  #Species Richness (Univariate)
          
    #Differences between parks 
          #base model 
          needle_univariate_nonvasc_park <- adonis2(needle_env_nonvasc$Species_Richness ~ Park + Plot,
                                               data = needle_env_nonvasc, 
                                               method = "euclidian",
                                               permutations = perm_design_needle_nonvasc,
                                               by = "terms")
          print(needle_univariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms11 <- rbind(1:nrow(needle_env_nonvasc),
                           shuffleSet(n = nrow(needle_env_nonvasc), 
                                      control = perm_design_needle_nonvasc, nset = 999))
          
          #create object for Ss to be stored 
          results11 <- matrix(nrow = nrow(perms11), ncol = 4)
          colnames(results11) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms11)) {
            temp.data <- needle_env_nonvasc[perms11[i, ], ]
            temp <- adonis2(needle_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results11[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results11 <- results11 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head11 <- head(results11)
          print.data.frame(head11)
          #calculate P value 
          with(results11, sum(F.Park >= F.Park[1]) / length(F.Park))

    #Differences through time 
          #base model 
          needle_univariate_nonvasc_time <- adonis2(needle_env_nonvasc$Species_Richness ~ Park + 
                                                      Plot + Sample_Year + Park*Sample_Year,
                                               data = needle_env_nonvasc, 
                                               method = "euclidian",
                                               permutations = perm_design_needle_time_nonvasc,
                                               by = "terms")
          print(needle_univariate_nonvasc_time)
          
          #hand calculate corrected F values
          #create permutation object 
          perms011 <- rbind(1:nrow(needle_env_nonvasc),
                           shuffleSet(n = nrow(needle_env_nonvasc), 
                                      control = perm_design_needle_nonvasc, nset = 999))
          
          #create object for Ss to be stored 
          results011 <- matrix(nrow = nrow(perms011), ncol = 6)
          colnames(results011) <- c("Park", "Plot", "Sample_Year", 
                                    "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms011)) {
            temp.data <- needle_env_nonvasc[perms011[i, ], ]
            temp <- adonis2(needle_env_nonvasc$Species_Richness ~ Park + Plot + 
                              Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results011[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results011 <- results011 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head011 <- head(results011)
          print.data.frame(head011)
          #calculate P value 
          with(results011, sum(F.Park >= F.Park[1]) / length(F.Park))

  ### Multivariate - Species Frequency 
          
        #differences between parks 
          #base model 
          needle_multivariate_nonvasc_park <- adonis2(needle_composition_nonvasc ~ Park + Plot, 
                                           data = needle_env_nonvasc, method = "bray", 
                                           permutations = perm_design_needle_nonvasc, 
                                           by = "terms")
          print(needle_multivariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms12 <- rbind(1:nrow(needle_composition_nonvasc),
                           shuffleSet(n = nrow(needle_composition_nonvasc), 
                                      control = perm_design_needle_nonvasc, nset = 999))
          results12 <- matrix(nrow = nrow(perms12), ncol = 4)
          colnames(results12) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms12)) {
            temp.data <- needle_env_nonvasc[perms12[i, ], ]
            temp <- adonis2(needle_composition_nonvasc ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results12[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results12 <- results12 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head12 <- head(results12)
          print.data.frame(head12)
          #calculate P value 
          with(results12, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          
    #differences through time 
          #base model 
          needle_multivariate_nonvasc_time <- adonis2(needle_composition_nonvasc ~ Park + Plot + 
                                                        Sample_Year + Park*Sample_Year, 
                                           data = needle_env_nonvasc, method = "bray", 
                                           permutations = perm_design_needle_time_nonvasc, 
                                           by = "terms")
          print(needle_multivariate_nonvasc_time)
          
          #create permutation structure and results object 
          perms012 <- rbind(1:nrow(needle_composition_nonvasc),
                           shuffleSet(n = nrow(needle_composition_nonvasc), 
                                      control = perm_design_needle_nonvasc, nset = 999))
          results012 <- matrix(nrow = nrow(perms012), ncol = 6)
          colnames(results012) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms012)) {
            temp.data <- needle_env_nonvasc[perms012[i, ], ]
            temp <- adonis2(needle_composition_nonvasc ~ Park + Plot + Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results012[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results012 <- results012 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/30))
          head012 <- head(results012)
          print.data.frame(head012)
          #calculate P value 
          with(results012, sum(F.Park >= F.Park[1]) / length(F.Park))
          
    #beta diversity 
          
        #based on park 
          needle_dispersion_result_nonvasc <- betadisper(vegdist(needle_composition_nonvasc, 
                                                                 method = "bray"), needle_env_nonvasc$Park)
          needle_dispersion_result_nonvasc 
          permutest(needle_dispersion_result_nonvasc, permutations = 999)
          
        #based on visit 
          needle_dispersion_result2_nonvasc <- betadisper(vegdist(needle_composition_nonvasc, 
                                                                  method = "bray"), needle_env_nonvasc$Visit)
          needle_dispersion_result2_nonvasc
          permutest(needle_dispersion_result2_nonvasc, permutations = 999)


```


# Open Low Shrub

## Building the Dataframes to be balanced - Code for reference (not required to run if using quick load)
```{r}
#vascular 
          #hand select the years for plots with more than the decided number of visits
      filter_criteria_openlow <- list(
        KATM_2009_01_078 = c(2015, 2021),
        KATM_2009_01_S008 = c(2015, 2021),
        KATM_2009_02_S004 = c(2016, 2023),
        KATM_2009_02_S008 = c(2016, 2023),
        LACL_2008_02_042 = c(2017, 2022),
        LACL_2010_01_014 = c(2015, 2021), 
        LACL_2010_01_026 = c(2015, 2021),
        LACL_2010_01_027 = c(2015, 2021),
        LACL_2010_01_051 = c(2015, 2022),
        LACL_2010_01_105 = c(2015, 2022),
        LACL_2010_02_016 = c(2016, 2022),
        LACL_2010_02_042 = c(2017, 2022),  
        LACL_2011_02_S997 = c(2016, 2022),
        LACL_2011_02_S999 = c(2016, 2022),
        LACL_2007_02_002 = c(2017, 2022),
        LACL_2007_02_017 = c(2015, 2021),
        LACL_2008_02_006 = c(2015, 2021),
        LACL_2008_02_049 = c(2017, 2022),  
        LACL_2010_02_999 = c(2016, 2022),
        LACL_2011_01_033 = c(2015, 2021),
        LACL_2007_02_006 = c(2015, 2022))
      
      #next identify plots with two plot visits 
      openlow_plots <- summary_table_vasc %>%
        filter(Viereck.3 == "Open Low Scrub", Number_Visits == 2) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(openlow_plots, names(filter_criteria_openlow))
      
      #subset main presence absence dataframe based on both conditions 
      #first verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
        filter(
          Plot %in% names(filter_criteria_openlow) & 
            Sample_Year %in% unlist(filter_criteria_openlow[Plot]))
      table(subset_hand_selected$Park, subset_hand_selected$Plot) 
      
      openlow_df <- quad_abundance_df_vascular_filtered %>%
        filter(
          (Plot %in% openlow_plots) | 
            (Plot %in% names(filter_criteria_openlow) &
               Sample_Year %in% unlist(filter_criteria_openlow[Plot])))
      
      table(openlow_df$Park, openlow_df$Plot) 
      
      #convert to frequency from PA
      openlow_vasc_abundance_balanced <- vasc_abundance_df %>%
        filter(Plot_Year %in% openlow_df$Plot_Year)
      openlow_df <- openlow_vasc_abundance_balanced 


#lichen
      #hand select the years for plots with more than the decided number of visits
      filter_criteria_openlow_lichen <- list(
        KATM_2009_01_078	= c(2015, 2021),
        KATM_2009_01_S008	= c(2015, 2021),
        LACL_2010_01_014	= c(2015, 2021),
        LACL_2010_01_026	= c(2015, 2021),
        LACL_2010_01_027	= c(2015, 2021),
        LACL_2010_01_051	= c(2015, 2022),
        LACL_2011_02_S997	= c(2016, 2022),
        LACL_2007_02_006	= c(2012, 2022),
        LACL_2011_01_033	= c(2015, 2021))
      
      #next identify plots with two plot visits 
      openlow_plots_lichen <- summary_table_lichens %>%
        filter(Viereck.3 == "Open Low Scrub", Number_Visits == 2) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(openlow_plots_lichen, names(filter_criteria_openlow_lichen))
      
      #subset main presence absence dataframe based on both conditions 
      #first verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_lichen_filtered %>%
        filter(
          Plot %in% names(filter_criteria_openlow_lichen) & 
            Sample_Year %in% unlist(filter_criteria_openlow_lichen[Plot]))
      table(subset_hand_selected$Park, subset_hand_selected$Plot) 
      
      openlow_df_lichen <- quad_abundance_df_lichen_filtered %>%
        filter(
          (Plot %in% openlow_plots_lichen) | 
            (Plot %in% names(filter_criteria_openlow_lichen) &
               Sample_Year %in% unlist(filter_criteria_openlow_lichen[Plot])))
      
      table(openlow_df_lichen$Park, openlow_df_lichen$Plot) 
      
      #convert to frequency from PA
      openlow_lichen_abundance_balanced <- lichen_abundance_df %>%
        filter(Plot_Year %in% openlow_df_lichen$Plot_Year)
      openlow_df_lichen <- openlow_lichen_abundance_balanced 

#nonvascular 
          #hand select the years for plots with more than the decided number of visits
      filter_criteria_openlow_nonvasc <- list(
        KATM_2009_01_078	= c(2015, 2021),
        KATM_2009_01_S008	= c(2015, 2021),
        LACL_2010_01_014	= c(2015, 2021),
        LACL_2010_01_026	= c(2015, 2021),
        LACL_2010_01_027	= c(2015, 2021),
        LACL_2010_01_051	= c(2015, 2022),
        LACL_2011_02_S997	= c(2016, 2022),
        LACL_2007_02_006	= c(2012, 2022),
        LACL_2011_01_033	= c(2015, 2021))
      
      #next identify plots with two plot visits 
      openlow_plots_nonvasc <- summary_table_nonvasc %>%
        filter(Viereck.3 == "Open Low Scrub", Number_Visits == 2) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(openlow_plots_nonvasc, names(filter_criteria_openlow_nonvasc))
      
      #subset main presence absence dataframe based on both conditions 
      #first verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_nonvasc_filtered %>%
        filter(
          Plot %in% names(filter_criteria_openlow_nonvasc) & 
            Sample_Year %in% unlist(filter_criteria_openlow_nonvasc[Plot]))
      table(subset_hand_selected$Park, subset_hand_selected$Plot) 
      
      openlow_df_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
        filter(
          (Plot %in% openlow_plots_nonvasc) | 
            (Plot %in% names(filter_criteria_openlow_nonvasc) &
               Sample_Year %in% unlist(filter_criteria_openlow_nonvasc[Plot])))
      
      table(openlow_df_nonvasc$Park, openlow_df_nonvasc$Plot) 
      
      #convert to frequency from PA
      openlow_nonvasc_abundance_balanced <- nonvasc_abundance_df %>%
        filter(Plot_Year %in% openlow_df_nonvasc$Plot_Year)
      openlow_df_nonvasc <- openlow_nonvasc_abundance_balanced

```

## Creating the env files - Code for reference (not required to run if using quick load)
```{r}
#Vascular 
      openlow_env <- openlow_df[,c(1:6)]
      
      #create visit column 
      openlow_env <- openlow_env %>%
        arrange(Plot, Sample_Year) %>%
        group_by(Plot) %>%
        mutate(Visit = paste0("visit_", row_number())) %>%
        ungroup()
      #add species richness column 
      openlow_env <- openlow_env %>%
        left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
     
#Lichen 
      openlow_env_lichen <- openlow_df_lichen[,c(1:8)]
     
      #create visit column 
      openlow_env_lichen <- openlow_env_lichen %>%
        arrange(Plot, Sample_Year) %>%
        group_by(Plot) %>%
        mutate(Visit = paste0("visit_", row_number())) %>%
        ungroup()   
      #add species richness column 
      openlow_env_lichen <- openlow_env_lichen %>%
        left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
      
#Nonvascular 
      openlow_env_nonvasc <- openlow_df_nonvasc[,c(1:8)]
      
      #create visit column 
      openlow_env_nonvasc <- openlow_env_nonvasc %>%
        arrange(Plot, Sample_Year) %>%
        group_by(Plot) %>%
        mutate(Visit = paste0("visit_", row_number())) %>%
        ungroup()
      #add species richness column 
      openlow_env_nonvasc <- openlow_env_nonvasc %>%
        left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
      
```

## Load data frames (Required)
```{r}
#quick pull from T drive 
openlow_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_df_vasc_filtered.xlsx"))
openlow_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_df_lichen_filtered.xlsx"))
openlow_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_df_nonvasc_filtered.xlsx"))

openlow_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_env_vasc_filtered.xlsx"))
openlow_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_env_lichen_filtered.xlsx"))
openlow_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/openlow_env_nonvasc_filtered.xlsx"))

openlow_env$Sample_Year <- as.numeric(openlow_env$Sample_Year)
openlow_env_lichen$Sample_Year <- as.numeric(openlow_env_lichen$Sample_Year)
openlow_env_nonvasc$Sample_Year <- as.numeric(openlow_env_nonvasc$Sample_Year) 
```

## Calculate Species Richness Averages and Standard Error (Optional)
```{r}
#open low shrub 
        openlow_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        openlow_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        openlow_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        openlow_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        openlow_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        openlow_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))

```

## Create composition matrices, and restrict permutations for PERMANOVA (Required)
```{r}
#Vascular 
      openlow_composition <- openlow_df[,c(8:261)]
      openlow_composition <- as.matrix(openlow_composition) 

      #design permutation structure 
      perm_design_openlow_time = how(
        plots = Plots(strata = openlow_env$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      perm_design_openlow = how(
        plots = Plots(strata = openlow_env$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)

#Lichen 
      openlow_composition_lichen <- openlow_df_lichen[,c(10:167)]
      openlow_composition_lichen <- as.matrix(openlow_composition_lichen) 
      
      #design permutation structure 
      perm_design_openlow_time_lichen = how(
        plots = Plots(strata = openlow_env_lichen$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      perm_design_openlow_lichen = how(
        plots = Plots(strata = openlow_env_lichen$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)

#Nonvascular 
      openlow_composition_nonvasc <- openlow_df_nonvasc[,c(10:210)]
      openlow_composition_nonvasc <- as.matrix(openlow_composition_nonvasc) 
      
      #design permutation structure 
      perm_design_openlow_time_nonvasc = how(
        plots = Plots(strata = openlow_env_nonvasc$Plot, type = c("free")),
        within = Within(type = "series", mirror = FALSE),
        nperm = 999)
      perm_design_openlow_nonvasc = how(
        plots = Plots(strata = openlow_env_nonvasc$Plot, type = c("free")),
        within = Within(type = "none"),
        nperm = 999)
      
openlow_env$Sample_Year <- as.numeric(openlow_env$Sample_Year)
openlow_env_lichen$Sample_Year <- as.numeric(openlow_env_lichen$Sample_Year)
openlow_env_nonvasc$Sample_Year <- as.numeric(openlow_env_nonvasc$Sample_Year)    
      
```

## Run PERMANOVA 
```{r}
#Vascular Species 
#Species richness (Univariate)
    #Differences between parks 
      check(openlow_env, control = perm_design_openlow) #check how many possible permutations - to catch obvious error in structure 
     
      #base model 
      openlow_univariate_vasc_park <- adonis2(openlow_env$Species_Richness ~ Park + Plot,
                                    data = openlow_env, 
                                    method = "euclidian",
                                    permutations = perm_design_openlow,
                                    by = "terms")
      print(openlow_univariate_vasc_park)
      
      #hand calculate corrected F values
      #create permutation object 
      perms13 <- rbind(1:nrow(openlow_env),
                       shuffleSet(n = nrow(openlow_env), control = perm_design_openlow, nset = 999))
      #create object for SS to be stored 
      results13 <- matrix(nrow = nrow(perms13), ncol = 4)
      colnames(results13) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms13)) {
        temp.data <- openlow_env[perms13[i, ], ]
        temp <- adonis2(openlow_env$Species_Richness ~ Park + Plot,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results13[i, ] <- t(temp$SumOfSqs)}
      
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results13 <- results13 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/34))
      head13 <- head(results13)
      print.data.frame(head13)
      #calculate P value 
      with(results13, sum(F.Park >= F.Park[1]) / length(F.Park))
      
      
  #Differences through time 
      check(openlow_env, control = perm_design_openlow) #check how many possible permutations
     
      #base model 
      openlow_univariate_vasc_time <- adonis2(openlow_env$Species_Richness ~ 
                                                Park + Plot + Sample_Year + Park*Sample_Year,
                                    data = openlow_env, 
                                    method = "euclidian",
                                    permutations = perm_design_openlow_time,
                                    by = "terms")
      print(openlow_univariate_vasc_time)
      
      #hand calculate corrected F values
      #create permutation object 
      perms013 <- rbind(1:nrow(openlow_env),
                       shuffleSet(n = nrow(openlow_env), control = perm_design_openlow, nset = 999))
      #create object for SS to be stored 
      results013 <- matrix(nrow = nrow(perms013), ncol = 6)
      colnames(results013) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms013)) {
        temp.data <- openlow_env[perms013[i, ], ]
        temp <- adonis2(openlow_env$Species_Richness ~ Park + Plot + Sample_Year + Park*Sample_Year,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results013[i, ] <- t(temp$SumOfSqs)}
      
      #create F value column and make sure to adjust DF in numerator and denominator if needed
      results013 <- results013 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/34))
      head013 <- head(results013)
      print.data.frame(head013)
      #calculate P value 
      with(results013, sum(F.Park >= F.Park[1]) / length(F.Park))

#species frequency (multivariate)
    #differences between parks 
      #base model 
      openlow_multivariate_vasc_park <- adonis2(openlow_composition ~ Park + Plot, 
                                data = openlow_env, method = "bray", 
                                permutations = perm_design_openlow, 
                                by = "terms")
      print(openlow_multivariate_vasc_park)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
      perms14 <- rbind(1:nrow(openlow_composition),
                       shuffleSet(n = nrow(openlow_composition), control = perm_design_openlow, nset = 999))
      results14 <- matrix(nrow = nrow(perms14), ncol = 4)
      colnames(results14) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms14)) {
        temp.data <- openlow_env[perms14[i, ], ]
        temp <- adonis2(openlow_composition ~ Park + Plot,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results14[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results14 <- results14 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/34))
      head14 <- head(results14)
      print.data.frame(head14)
      #calculate P value 
      with(results14, sum(F.Park >= F.Park[1]) / length(F.Park))

      
    #differences through time 
      #base model 
      openlow_multivariate_vasc_time <- adonis2(openlow_composition ~ Park + Plot + 
                                                  Sample_Year + Park*Sample_Year, 
                                data = openlow_env, method = "bray", 
                                permutations = perm_design_openlow_time, 
                                by = "terms")
      print(openlow_multivariate_vasc_time)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
      perms014 <- rbind(1:nrow(openlow_composition),
                       shuffleSet(n = nrow(openlow_composition), control = perm_design_openlow, nset = 999))
      results014 <- matrix(nrow = nrow(perms014), ncol = 6)
      colnames(results14) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms014)) {
        temp.data <- openlow_env[perms014[i, ], ]
        temp <- adonis2(openlow_composition ~ Park + Plot + Sample_Year + Park*Sample_Year,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results014[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results014 <- results014 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/34))
      head014 <- head(results014)
      print.data.frame(head014)
      #calculate P value 
      with(results014, sum(F.Park >= F.Park[1]) / length(F.Park))

#beta diversity 
    #based on park 
      openlow_dispersion_result <- betadisper(vegdist(openlow_composition, 
                                                      method = "bray"), openlow_env$Park)
      openlow_dispersion_result 
      permutest(openlow_dispersion_result, permutations = 999)
      
    #based on visit 
      openlow_dispersion_result2 <- betadisper(vegdist(openlow_composition, 
                                                       method = "bray"), openlow_env$Visit)
      openlow_dispersion_result2 
      permutest(openlow_dispersion_result2, permutations = 999)

----------------------------------------------------------------------------------------------------------------
#Lichen 
      
    ### Univariate 
      #Differences between parks 
      check(openlow_env_lichen, control = perm_design_openlow_lichen) #how many possible permutations 
      
      #Base Model 
      openlow_univariate_lichen_park <- adonis2(openlow_env_lichen$Species_Richness ~ Park + Plot,
                                    data = openlow_env_lichen, 
                                    method = "euclidian",
                                    permutations = perm_design_openlow_lichen,
                                    by = "terms")
      print(openlow_univariate_lichen_park)
      
      #hand calculate corrected F values
      #create permutation object 
      perms15 <- rbind(1:nrow(openlow_env_lichen),
                       shuffleSet(n = nrow(openlow_env_lichen), control = perm_design_openlow_lichen, nset = 999))
      
      #create object for Ss to be stored 
      results15 <- matrix(nrow = nrow(perms15), ncol = 4)
      colnames(results15) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms15)) {
        temp.data <- openlow_env_lichen[perms15[i, ], ]
        temp <- adonis2(openlow_env_lichen$Species_Richness ~ Park + Plot,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results15[i, ] <- t(temp$SumOfSqs)
      }
      
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results15 <- results15 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/26))
      head15 <- head(results15)
      print.data.frame(head15)
      #calculate P value 
      with(results15, sum(F.Park >= F.Park[1]) / length(F.Park))

      
      
  #Differences through time  
      check(openlow_env_lichen, control = perm_design_openlow_lichen) #how many possible permutations 
      #Base Model 
      openlow_univariate_lichen_time <- adonis2(openlow_env_lichen$Species_Richness ~ Park + 
                                                  Plot + Sample_Year + Park*Sample_Year,
                                    data = openlow_env_lichen, 
                                    method = "euclidian",
                                    permutations = perm_design_openlow_time_lichen,
                                    by = "terms")
      print(openlow_univariate_lichen_time)
      
      #hand calculate corrected F values
      #create permutation object 
      perms015 <- rbind(1:nrow(openlow_env_lichen),
                       shuffleSet(n = nrow(openlow_env_lichen), control = perm_design_openlow_lichen, nset = 999))
      
      #create object for Ss to be stored 
      results015 <- matrix(nrow = nrow(perms015), ncol = 6)
      colnames(results015) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms015)) {
        temp.data <- openlow_env_lichen[perms015[i, ], ]
        temp <- adonis2(openlow_env_lichen$Species_Richness ~ Park + Plot + Sample_Year + Park*Sample_Year,
                        data = temp.data,
                        method = "euclidian",
                        by = "terms",
                        permutations = 0)
        results015[i, ] <- t(temp$SumOfSqs)
      }
      
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results015 <- results015 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/26))
      head015 <- head(results015)
      print.data.frame(head015)
      #calculate P value 
      with(results015, sum(F.Park >= F.Park[1]) / length(F.Park))
    

      
### Multivariate 
  #differences between parks 
      #base model 
      openlow_multivariate_lichen_park <- adonis2(openlow_composition_lichen ~ Park + Plot, 
                                data = openlow_env_lichen, method = "bray", 
                                permutations = perm_design_openlow_lichen, 
                                by = "terms")
      print(openlow_multivariate_lichen_park)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
      perms16 <- rbind(1:nrow(openlow_composition_lichen),
                       shuffleSet(n = nrow(openlow_composition_lichen), 
                                  control = perm_design_openlow_lichen, nset = 999))
      results16 <- matrix(nrow = nrow(perms16), ncol = 4)
      colnames(results16) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
      for (i in 1:nrow(perms16)) {
        temp.data <- openlow_env_lichen[perms16[i, ], ]
        temp <- adonis2(openlow_composition_lichen ~ Park + Plot,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results16[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results16 <- results16 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/26))
      head16 <- head(results16)
      print.data.frame(head16)
      #calculate P value 
      with(results16, sum(F.Park >= F.Park[1]) / length(F.Park))



  #Differences through time (Species Frequency)
      #base model 
      openlow_multivariate_lichen_time <- adonis2(openlow_composition_lichen ~ Park + 
                                                    Plot + Sample_Year + Park*Sample_Year, 
                                data = openlow_env_lichen, method = "bray", 
                                permutations = perm_design_openlow_time_lichen, 
                                by = "terms")
      print(openlow_multivariate_lichen_time)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
      perms016 <- rbind(1:nrow(openlow_composition_lichen),
                       shuffleSet(n = nrow(openlow_composition_lichen), 
                                  control = perm_design_openlow_lichen, nset = 999))
      results016 <- matrix(nrow = nrow(perms016), ncol = 6)
      colnames(results016) <- c("Park", "Plot", "Sample_Year", 
                                "Park*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
      for (i in 1:nrow(perms016)) {
        temp.data <- openlow_env_lichen[perms016[i, ], ]
        temp <- adonis2(openlow_composition_lichen ~ Park + Plot + Sample_Year + Park*Sample_Year,
                        data = temp.data,
                        method = "bray",
                        by = "terms",
                        permutations = 0)
        results016[i, ] <- t(temp$SumOfSqs)
      }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
      results016 <- results016 |>
        data.frame() |>
        mutate(F.Park = (Park/1)/(Plot/26))
      head016 <- head(results016)
      print.data.frame(head016)
      
      #calculate P value 
      with(results016, sum(F.Park >= F.Park[1]) / length(F.Park))


#beta diversity 
  #based on park 
    openlow_dispersion_result_lichen <- betadisper(vegdist(openlow_composition_lichen, 
                                                    method = "bray"), openlow_env_lichen$Park)
    openlow_dispersion_result_lichen 
    permutest(openlow_dispersion_result_lichen, permutations = 999)
    
  #based on visit 
    openlow_dispersion_result2_lichen <- betadisper(vegdist(openlow_composition_lichen, 
                                                     method = "bray"), openlow_env_lichen$Visit)
    openlow_dispersion_result2_lichen 
    permutest(openlow_dispersion_result2_lichen, permutations = 999)

----------------------------------------------------------------------------------------------------------------

#Nonvascular 
    
  ### Univariate (Species Richness)
    #Differences between parks 
      check(openlow_env_nonvasc, control = perm_design_openlow_nonvasc) #how many possible permutations 
      
      #base model 
      openlow_univariate_nonvasc_park <- adonis2(openlow_env_nonvasc$Species_Richness ~ Park + Plot,
                                           data = openlow_env_nonvasc, 
                                           method = "euclidian",
                                           permutations = perm_design_openlow_nonvasc,
                                           by = "terms")
      print(openlow_univariate_nonvasc_park)
      
      #hand calculate corrected F values
      #create permutation object 
          perms17 <- rbind(1:nrow(openlow_env_nonvasc),
                       shuffleSet(n = nrow(openlow_env_nonvasc), 
                                  control = perm_design_openlow_nonvasc, nset = 999))
      
      #create object for Ss to be stored 
          results17 <- matrix(nrow = nrow(perms17), ncol = 4)
          colnames(results17) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms17)) {
            temp.data <- openlow_env_nonvasc[perms17[i, ], ]
            temp <- adonis2(openlow_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results17[i, ] <- t(temp$SumOfSqs)
          }
      
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results17 <- results17 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/26))
          head17 <- head(results17)
          print.data.frame(head17)
      #calculate P value 
          with(results17, sum(F.Park >= F.Park[1]) / length(F.Park))


  #Differences through time  
      check(openlow_env_nonvasc, control = perm_design_openlow_nonvasc) #how many possible permutations 
      
      #base model 
      openlow_univariate_nonvasc_time <- adonis2(openlow_env_nonvasc$Species_Richness ~ 
                                                   Park + Plot + Sample_Year + Park*Sample_Year,
                                           data = openlow_env_nonvasc, 
                                           method = "euclidian",
                                           permutations = perm_design_openlow_time_nonvasc,
                                           by = "terms")
      print(openlow_univariate_nonvasc_time)
      
      #hand calculate corrected F values
      #create permutation object 
          perms017 <- rbind(1:nrow(openlow_env_nonvasc),
                       shuffleSet(n = nrow(openlow_env_nonvasc), 
                                  control = perm_design_openlow_nonvasc, nset = 999))
      
      #create object for Ss to be stored 
          results017 <- matrix(nrow = nrow(perms017), ncol = 6)
          colnames(results017) <- c("Park", "Plot", "Sample_Year", "Park*Sample_Year", 
                                    "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms017)) {
            temp.data <- openlow_env_nonvasc[perms017[i, ], ]
            temp <- adonis2(openlow_env_nonvasc$Species_Richness ~ Park + Plot + 
                              Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results017[i, ] <- t(temp$SumOfSqs)
          }
      
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results017 <- results017 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/26))
          head017 <- head(results017)
          print.data.frame(head017)
      #calculate P value 
          with(results017, sum(F.Park >= F.Park[1]) / length(F.Park))


### Multivariate (species frequency)
    #differences between parks 
      #base model 
      openlow_multivariate_nonvasc_park <- adonis2(openlow_composition_nonvasc ~ Park + Plot, 
                                       data = openlow_env_nonvasc, method = "bray", 
                                       permutations = perm_design_openlow_nonvasc, 
                                       by = "terms")
      print(openlow_multivariate_nonvasc_park)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
          perms18 <- rbind(1:nrow(openlow_composition_nonvasc),
                           shuffleSet(n = nrow(openlow_composition_nonvasc), 
                                      control = perm_design_openlow_nonvasc, nset = 999))
          results18 <- matrix(nrow = nrow(perms18), ncol = 4)
          colnames(results18) <- c("Park", "Plot", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms18)) {
            temp.data <- openlow_env_nonvasc[perms18[i, ], ]
            temp <- adonis2(openlow_composition_nonvasc ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results18[i, ] <- t(temp$SumOfSqs)
          }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results18 <- results18 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/26))
          head18 <- head(results18)
          print.data.frame(head18)
      #calculate P value 
          with(results18, sum(F.Park >= F.Park[1]) / length(F.Park))


          
  #differences through time 
      #base model 
      openlow_multivariate_nonvasc_time <- adonis2(openlow_composition_nonvasc ~ 
                                                     Park + Plot + Sample_Year + Park*Sample_Year, 
                                       data = openlow_env_nonvasc, method = "bray", 
                                       permutations = perm_design_openlow_time_nonvasc, 
                                       by = "terms")
      print(openlow_multivariate_nonvasc_time)
      
      #hand calculate corrected F values
      #create permutation structure and results object 
          perms018 <- rbind(1:nrow(openlow_composition_nonvasc),
                           shuffleSet(n = nrow(openlow_composition_nonvasc), 
                                      control = perm_design_openlow_nonvasc, nset = 999))
          results018 <- matrix(nrow = nrow(perms018), ncol = 6)
          colnames(results018) <- c("Park", "Plot", "Sample_Year", 
                                    "Park*Sample_Year", "Residual", "Total")
      
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms018)) {
            temp.data <- openlow_env_nonvasc[perms018[i, ], ]
            temp <- adonis2(openlow_composition_nonvasc ~ Park + Plot + 
                              Sample_Year + Park*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results018[i, ] <- t(temp$SumOfSqs)
          }
      
      #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results018 <- results018 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/26))
          head018 <- head(results018)
          print.data.frame(head018)
      
      #calculate P value 
          with(results018, sum(F.Park >= F.Park[1]) / length(F.Park))

#beta diversity 
  #based on park 
    openlow_dispersion_result_nonvasc <- betadisper(vegdist(openlow_composition_nonvasc, 
                                                           method = "bray"), openlow_env_nonvasc$Park)
    openlow_dispersion_result_nonvasc 
    permutest(openlow_dispersion_result_nonvasc, permutations = 999)
    
  #based on visit 
    openlow_dispersion_result2_nonvasc <- betadisper(vegdist(openlow_composition_nonvasc, 
                                                            method = "bray"), openlow_env_nonvasc$Visit)
    openlow_dispersion_result2_nonvasc 
    permutest(openlow_dispersion_result2_nonvasc, permutations = 999)
```



# Dwarf Scrub 

## Building the dataframes to be balanced, code for reference (not required to run if using quick load)
```{r}
#vascular 
    #hand select the years for plots with more than the decided number of visits
          filter_criteria_dwarfscrub <- list(
            LACL_2010_03_001	= c(2011, 2016, 2023),
            KATM_2009_02_048	= c(2011, 2016, 2023),
            KATM_2010_03_049	= c(2011, 2016, 2023))
          
          #next identify plots with three plot visits 
          dwarfscrub_plots <- summary_table_vasc %>%
            filter(Viereck.2 == "Dwarf Scrub", Number_Visits == 3) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(dwarfscrub_plots, names(filter_criteria_dwarfscrub))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
            filter(
              Plot %in% names(filter_criteria_dwarfscrub) & 
                Sample_Year %in% unlist(filter_criteria_dwarfscrub[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          dwarfscrub_df <- quad_abundance_df_vascular_filtered %>%
            filter(
              (Plot %in% dwarfscrub_plots) | 
                (Plot %in% names(filter_criteria_dwarfscrub) &
                   Sample_Year %in% unlist(filter_criteria_dwarfscrub[Plot])))
          
          #verify everything has two sample visits 
          table(dwarfscrub_df$Park, dwarfscrub_df$Plot)
          
          #convert to frequency from PA
          dwarfscrub_vasc_abundance_balanced <- vasc_abundance_df %>%
            filter(Plot_Year %in% dwarfscrub_df$Plot_Year)
          dwarfscrub_df <- dwarfscrub_vasc_abundance_balanced 
          
          
#lichen 
     #hand select the years for plots with more than the decided number of visits
          filter_criteria_dwarfscrub_lichens <- list(
            LACL_2010_03_998	= c(2011, 2016),
            KATM_2009_02_048	= c(2011, 2016),
            KATM_2010_03_049	= c(2011, 2016))
          
          
          #next identify plots with two plot visits 
          dwarfscrub_plots_lichens <- summary_table_lichens %>%
            filter(Viereck.2 == "Dwarf Scrub", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(dwarfscrub_plots_lichens, names(filter_criteria_dwarfscrub_lichens))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_lichen_filtered %>%
            filter(
              Plot %in% names(filter_criteria_dwarfscrub_lichens) & 
                Sample_Year %in% unlist(filter_criteria_dwarfscrub_lichens[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          dwarfscrub_df_lichens <- quad_abundance_df_lichen_filtered %>%
            filter(
              (Plot %in% dwarfscrub_plots_lichens) | 
                (Plot %in% names(filter_criteria_dwarfscrub_lichens) &
                   Sample_Year %in% unlist(filter_criteria_dwarfscrub_lichens[Plot])))
          
          #verify everything has two sample visits 
          table(dwarfscrub_df_lichens$Park, dwarfscrub_df_lichens$Plot)
          
          #convert to frequency from PA
          dwarfscrub_lichen_abundance_balanced <- lichen_abundance_df %>%
            filter(Plot_Year %in% dwarfscrub_df_lichen$Plot_Year)
          dwarfscrub_df_lichen <- dwarfscrub_lichen_abundance_balanced
          
          
#nonvascular 
        #hand select the years for plots with more than the decided number of visits
          filter_criteria_dwarfscrub_nonvasc <- list(
            LACL_2010_03_998	= c(2011, 2016),
            KATM_2009_02_048	= c(2011, 2016),
            KATM_2010_03_049	= c(2011, 2016))
          
          
          #next identify plots with two plot visits 
          dwarfscrub_plots_nonvasc <- summary_table_nonvasc %>%
            filter(Viereck.2 == "Dwarf Scrub", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(dwarfscrub_plots_nonvasc, names(filter_criteria_dwarfscrub_nonvasc))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              Plot %in% names(filter_criteria_dwarfscrub_nonvasc) & 
                Sample_Year %in% unlist(filter_criteria_dwarfscrub_nonvasc[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          dwarfscrub_df_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              (Plot %in% dwarfscrub_plots_nonvasc) | 
                (Plot %in% names(filter_criteria_dwarfscrub_nonvasc) &
                   Sample_Year %in% unlist(filter_criteria_dwarfscrub_nonvasc[Plot])))
          
          #verify everything has two sample visits 
          table(dwarfscrub_df_nonvasc$Park, dwarfscrub_df_nonvasc$Plot)
          
          #convert to frequency from PA
          dwarfscrub_nonvasc_abundance_balanced <- nonvasc_abundance_df %>%
            filter(Plot_Year %in% dwarfscrub_df_nonvasc$Plot_Year)
          dwarfscrub_df_nonvasc <- dwarfscrub_nonvasc_abundance_balanced
```


## Creating the env files, code for reference (not required to run if using quick load)
```{r}
#vascular 
          dwarfscrub_env <- dwarfscrub_df[,c(1:6)]
          
          #Adding visit column 
          dwarfscrub_env <- dwarfscrub_env %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #adding species richness column 
          dwarfscrub_env <- dwarfscrub_env %>%
            left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          
#lichen 
          dwarfscrub_env_lichen <- dwarfscrub_df_lichen[,c(1:8)]
          
          #add visit column
          dwarfscrub_env_lichen <- dwarfscrub_env_lichen %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #Add species richness column
          dwarfscrub_env_lichen <- dwarfscrub_env_lichen %>%
            left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          
#nonvascular 
          dwarfscrub_env_nonvasc <- dwarfscrub_df_nonvasc[,c(1:8)]
          
          #Add visit column
          dwarfscrub_env_nonvasc <- dwarfscrub_env_nonvasc %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #add species richness column
          dwarfscrub_env_nonvasc <- dwarfscrub_env_nonvasc %>%
            left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
```

## Load Data Frames (Required)
```{r}
#quick Load from T drive 
dwarfscrub_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_df_vasc_filtered.xlsx"))
dwarfscrub_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_df_lichen_filtered.xlsx"))
dwarfscrub_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_df_nonvasc_filtered.xlsx"))  
  
dwarfscrub_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_env_vasc_filtered.xlsx"))
dwarfscrub_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_env_lichen_filtered.xlsx"))
dwarfscrub_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/dwarfscrub_env_nonvasc_filtered.xlsx")) 

dwarfscrub_env$Sample_Year <- as.numeric(dwarfscrub_env$Sample_Year)
dwarfscrub_env_lichen$Sample_Year <- as.numeric(dwarfscrub_env_lichen$Sample_Year)
dwarfscrub_env_nonvasc$Sample_Year <- as.numeric(dwarfscrub_env_nonvasc$Sample_Year) 
```

## Calculate Species Richness Averages and Standard Error (Optional)
```{r}
#dwarf shrub 
        dwarfscrub_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        dwarfscrub_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        dwarfscrub_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        dwarfscrub_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        dwarfscrub_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        dwarfscrub_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))

```

## Create composition matrices, and restrict permutations for PERMANOVA (Required)
```{r}
#Vascular 
          dwarfscrub_composition <- dwarfscrub_df[,c(8:261)]
          dwarfscrub_composition <- as.matrix(dwarfscrub_composition) 
          
          #design permutation structure 
          #For time based models 
          perm_design_dwarfscrub_time = how(
            plots = Plots(strata = dwarfscrub_env$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          #for the park model 
          perm_design_dwarfscrub = how(
            plots = Plots(strata = dwarfscrub_env$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)

#Lichen 
          dwarfscrub_composition_lichen <- dwarfscrub_df_lichen[,c(10:167)]
          dwarfscrub_composition_lichen <- as.matrix(dwarfscrub_composition_lichen) 

          #design permutation structure 
          #for time based models 
          perm_design_dwarfscrub_time_lichen = how(
            plots = Plots(strata = dwarfscrub_env_lichen$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          #for the park model 
          perm_design_dwarfscrub_lichen = how(
            plots = Plots(strata = dwarfscrub_env_lichen$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)

#Nonvascular 

          dwarfscrub_composition_nonvasc <- dwarfscrub_df_nonvasc[,c(10:210)]
          dwarfscrub_composition_nonvasc <- as.matrix(dwarfscrub_composition_nonvasc) 
          
          #design permutation structure 
          #for time based models 
          perm_design_dwarfscrub_time_nonvasc = how(
            plots = Plots(strata = dwarfscrub_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          #for park model 
          perm_design_dwarfscrub_nonvasc = how(
            plots = Plots(strata = dwarfscrub_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)

```

## Run PERMANOVA 
```{r}
#Vascular 
    ### Univariate (species richness)
    #Differences between parks 
          check(dwarfscrub_env, control = perm_design_dwarfscrub) #how many possible permutations 
          
        #Base model 
          dwarfscrub_univariate_vasc_park <- adonis2(dwarfscrub_env$Species_Richness ~ Park + Plot,
                                           data = dwarfscrub_env, 
                                           method = "euclidian",
                                           permutations = perm_design_dwarfscrub,
                                           by = "terms")
          print(dwarfscrub_univariate_vasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms19 <- rbind(1:nrow(dwarfscrub_env),
                           shuffleSet(n = nrow(dwarfscrub_env), 
                                      control = perm_design_dwarfscrub, nset = 999))
          
          #create object for Ss to be stored 
          results19 <- matrix(nrow = nrow(perms19), ncol = 4)
          colnames(results19) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms19)) {
            temp.data <- dwarfscrub_env[perms19[i, ], ]
            temp <- adonis2(dwarfscrub_env$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results19[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results19 <- results19 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/17))
          head19 <- head(results19)
          print.data.frame(head19)
          #calculate P value 
          with(results19, sum(F.Park >= F.Park[1]) / length(F.Park))

          
  #Differences between subclasses 
          check(dwarfscrub_env, control = perm_design_dwarfscrub) #how many possible permutations 
          
        #Base model 
          dwarfscrub_univariate_vasc_subclass <- adonis2(dwarfscrub_env$Species_Richness ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                                           data = dwarfscrub_env, 
                                           method = "euclidian",
                                           permutations = perm_design_dwarfscrub_time,
                                           by = "terms")
          print(dwarfscrub_univariate_vasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms019 <- rbind(1:nrow(dwarfscrub_env),
                           shuffleSet(n = nrow(dwarfscrub_env), 
                                      control = perm_design_dwarfscrub, nset = 999))
          
          #create object for Ss to be stored 
          results019 <- matrix(nrow = nrow(perms019), ncol = 7)
          colnames(results019) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms019)) {
            temp.data <- dwarfscrub_env[perms019[i, ], ]
            temp <- adonis2(dwarfscrub_env$Species_Richness ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results019[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results019 <- results019 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/16))
          head019 <- head(results019)
          print.data.frame(head019)
          
          #calculate P value 
          with(results019, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #create F value column - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results019 <- results019 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/16))
          head019 <- head(results019)
          print.data.frame(head019)
          #calculate P value 
          with(results019, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
 

  ### Multivariate (species frequency)
      #differences between parks 
          #base model 
          dwarfscrub_multivariate_vasc_park <- adonis2(dwarfscrub_composition ~ Park + Plot, 
                                       data = dwarfscrub_env, method = "bray", 
                                       permutations = perm_design_dwarfscrub, 
                                       by = "terms")
          print(dwarfscrub_multivariate_vasc_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms20 <- rbind(1:nrow(dwarfscrub_composition),
                           shuffleSet(n = nrow(dwarfscrub_composition), 
                                      control = perm_design_dwarfscrub, nset = 999))
          results20 <- matrix(nrow = nrow(perms20), ncol = 4)
          colnames(results20) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms20)) {
            temp.data <- dwarfscrub_env[perms20[i, ], ]
            temp <- adonis2(dwarfscrub_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results20[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results20 <- results20 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/17))
          head20 <- head(results20)
          print.data.frame(head20)
          #calculate P value 
          with(results20, sum(F.Park >= F.Park[1]) / length(F.Park))
          
    #differences between subclasses 
          #base model 
          dwarfscrub_multivariate_vasc_subclass <- adonis2(dwarfscrub_composition ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year,, 
                                       data = dwarfscrub_env, method = "bray", 
                                       permutations = perm_design_dwarfscrub_time, 
                                       by = "terms")
          print(dwarfscrub_multivariate_vasc_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms020 <- rbind(1:nrow(dwarfscrub_composition),
                           shuffleSet(n = nrow(dwarfscrub_composition), 
                                      control = perm_design_dwarfscrub, nset = 999))
          results020 <- matrix(nrow = nrow(perms020), ncol = 7)
          colnames(results020) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms020)) {
            temp.data <- dwarfscrub_env[perms020[i, ], ]
            temp <- adonis2(dwarfscrub_composition ~ Viereck.3 + Park + 
                                                            Plot + Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results020[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results020 <- results020 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/16))
          head020 <- head(results020)
          print.data.frame(head020)
          
          #calculate P value 
          with(results020, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #calculate F statistics for each permutation using correct equation 
          results020 <- results020 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/16))
          head020 <- head(results020)
          print.data.frame(head020)
          #calculate P value 
          with(results020, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
          
    #beta diversity 
        #park 
          dwarfscrub_dispersion_result <- betadisper(vegdist(dwarfscrub_composition, 
                                                             method = "bray"), dwarfscrub_env$Park)
          dwarfscrub_dispersion_result 
          permutest(dwarfscrub_dispersion_result, permutations = 999)
          
        #based on visit 
          dwarfscrub_dispersion_result2 <- betadisper(vegdist(dwarfscrub_composition, 
                                                              method = "bray"), dwarfscrub_env$Visit)
          dwarfscrub_dispersion_result2 
          permutest(dwarfscrub_dispersion_result2, permutations = 999)
          
        #based on viereck
          dwarfscrub_dispersion_result3 <- betadisper(vegdist(dwarfscrub_composition, 
                                                              method = "bray"), dwarfscrub_env$Viereck.3)
          dwarfscrub_dispersion_result3 
          permutest(dwarfscrub_dispersion_result3, permutations = 999)

---------------------------------------------------------------------------------------------------------------- 
#Lichen 
    ### Univariate (species richness)
    #Differences between parks 
          check(dwarfscrub_env_lichen, control = perm_design_dwarfscrub_lichen) #how many possible permutations 
          
          
        #base model 
          dwarfscrub_univariate_lichen_park <- adonis2(dwarfscrub_env_lichen$Species_Richness ~ Park + Plot,
                                                   data = dwarfscrub_env_lichen, 
                                                   method = "euclidian",
                                                   permutations = perm_design_dwarfscrub_lichen,
                                                   by = "terms")
          print(dwarfscrub_univariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms21 <- rbind(1:nrow(dwarfscrub_env_lichen),
                           shuffleSet(n = nrow(dwarfscrub_env_lichen), 
                                      control = perm_design_dwarfscrub_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results21 <- matrix(nrow = nrow(perms21), ncol = 4)
          colnames(results21) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms21)) {
            temp.data <- dwarfscrub_env_lichen[perms21[i, ], ]
            temp <- adonis2(dwarfscrub_env_lichen$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results21[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results21 <- results21 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/14))
          head21 <- head(results21)
          print.data.frame(head21)
          #calculate P value 
          with(results21, sum(F.Park >= F.Park[1]) / length(F.Park))

    #Differences between subclasses  
          check(dwarfscrub_env_lichen, control = perm_design_dwarfscrub_lichen) #how many possible permutations 
          
          #base model 
          dwarfscrub_univariate_lichen_subclass <- adonis2(dwarfscrub_env_lichen$Species_Richness ~ 
                                                             Viereck.3 + Park + Plot + Sample_Year +
                                                             Viereck.3*Sample_Year,
                                                   data = dwarfscrub_env_lichen, 
                                                   method = "euclidian",
                                                   permutations = perm_design_dwarfscrub_time_lichen,
                                                   by = "terms")
          print(dwarfscrub_univariate_lichen_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms021 <- rbind(1:nrow(dwarfscrub_env_lichen),
                           shuffleSet(n = nrow(dwarfscrub_env_lichen), 
                                      control = perm_design_dwarfscrub_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results021 <- matrix(nrow = nrow(perms021), ncol = 7)
          colnames(results021) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms021)) {
            temp.data <- dwarfscrub_env_lichen[perms021[i, ], ]
            temp <- adonis2(dwarfscrub_env_lichen$Species_Richness ~ Viereck.3 + Park + Plot + Sample_Year + 
                              Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results021[i, ] <- t(temp$SumOfSqs)
          }
          
      #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results021 <- results021 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/13))
          head021 <- head(results021)
          print.data.frame(head021)
          #calculate P value 
          with(results021, sum(F.Park >= F.Park[1]) / length(F.Park))
          
      #create F value column - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results021 <- results021 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/2)/(Plot/13))
          head021 <- head(results021)
          print.data.frame(head021)
          #calculate P value 
          with(results021, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
        
          
  ### Multivariate (species frequency)
      #differences between parks 
          #base model 
          dwarfscrub_multivariate_lichen_park <- adonis2(dwarfscrub_composition_lichen ~ Park + Plot, 
                                               data = dwarfscrub_env_lichen, method = "bray", 
                                               permutations = perm_design_dwarfscrub_lichen, 
                                               by = "terms")
          print(dwarfscrub_multivariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms22 <- rbind(1:nrow(dwarfscrub_composition_lichen),
                           shuffleSet(n = nrow(dwarfscrub_composition_lichen), 
                                      control = perm_design_dwarfscrub_lichen, nset = 999))
          #head(perms18)
          results22 <- matrix(nrow = nrow(perms22), ncol = 4)
          colnames(results22) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms22)) {
            temp.data <- dwarfscrub_env_lichen[perms22[i, ], ]
            temp <- adonis2(dwarfscrub_composition_lichen ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results22[i, ] <- t(temp$SumOfSqs)
          }
          
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results22 <- results22 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/14))
          head22 <- head(results22)
          print.data.frame(head22)
          #calculate P value 
          with(results22, sum(F.Park >= F.Park[1]) / length(F.Park))

          
    #differences between subclasses
          #base model 
          dwarfscrub_multivariate_lichen_subclass <- adonis2(dwarfscrub_composition_lichen ~ Viereck.3 + Park + 
                                                               Plot + Sample_Year + Viereck.3*Sample_Year, 
                                               data = dwarfscrub_env_lichen, method = "bray", 
                                               permutations = perm_design_dwarfscrub_time_lichen, 
                                               by = "terms")
          print(dwarfscrub_multivariate_lichen_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms022 <- rbind(1:nrow(dwarfscrub_composition_lichen),
                           shuffleSet(n = nrow(dwarfscrub_composition_lichen), 
                                      control = perm_design_dwarfscrub_lichen, nset = 999))
          results022 <- matrix(nrow = nrow(perms022), ncol = 7)
          colnames(results022) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms022)) {
            temp.data <- dwarfscrub_env_lichen[perms022[i, ], ]
            temp <- adonis2(dwarfscrub_composition_lichen ~ Viereck.3 + Park + Plot + Sample_Year + 
                              Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results022[i, ] <- t(temp$SumOfSqs)
          }
          
          
      #calculate F statistic for Park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results022 <- results022 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/13))
          head022 <- head(results022)
          print.data.frame(head022)
          #calculate P value 
          with(results022, sum(F.Park >= F.Park[1]) / length(F.Park))
          
      #calculate F statistic for viereck class - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results022 <- results022 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/2)/(Plot/13))
          head022 <- head(results022)
          print.data.frame(head022)
          #calculate P value 
          with(results022, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

  #beta diversity 
        #park 
          dwarfscrub_dispersion_result_lichen <- betadisper(vegdist(dwarfscrub_composition_lichen, 
                                                                     method = "bray"), dwarfscrub_env_lichen$Park)
          dwarfscrub_dispersion_result_lichen 
          permutest(dwarfscrub_dispersion_result_lichen, permutations = 999)
          
        #based on visit 
          dwarfscrub_dispersion_result2_lichen <- betadisper(vegdist(dwarfscrub_composition_lichen, 
                                                                      method = "bray"), dwarfscrub_env_lichen$Visit)
          dwarfscrub_dispersion_result2_lichen
          permutest(dwarfscrub_dispersion_result2_lichen, permutations = 999)
          
        #based on viereck subclass
          dwarfscrub_dispersion_result3_lichen <- betadisper(vegdist(dwarfscrub_composition_lichen, 
                                                                      method = "bray"), dwarfscrub_env_lichen$Viereck.3)
          dwarfscrub_dispersion_result3_lichen
          permutest(dwarfscrub_dispersion_result3_lichen, permutations = 999)
          
          
          
----------------------------------------------------------------------------------------------------------------           
          
#Nonvascular 
      ### Univariate 
        #differences between parks 
          check(dwarfscrub_env_nonvasc, control = perm_design_dwarfscrub_nonvasc) #how many possible permutations 
          #base model 
          dwarfscrub_univariate_nonvasc_park <- adonis2(dwarfscrub_env_nonvasc$Species_Richness ~ Park + Plot,
                                                   data = dwarfscrub_env_nonvasc, 
                                                   method = "euclidian",
                                                   permutations = perm_design_dwarfscrub_nonvasc,
                                                   by = "terms")
          print(dwarfscrub_univariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms23 <- rbind(1:nrow(dwarfscrub_env_nonvasc),
                           shuffleSet(n = nrow(dwarfscrub_env_nonvasc), 
                                      control = perm_design_dwarfscrub_nonvasc, nset = 999))
          
          #create object for SS to be stored 
          results23 <- matrix(nrow = nrow(perms23), ncol = 4)
          colnames(results23) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms23)) {
            temp.data <- dwarfscrub_env_nonvasc[perms23[i, ], ]
            temp <- adonis2(dwarfscrub_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results23[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results23 <- results23 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/14))
          head23 <- head(results23)
          print.data.frame(head23)
          #calculate P value 
          with(results23, sum(F.Park >= F.Park[1]) / length(F.Park))

    #differences between subclasses  
          check(dwarfscrub_env_nonvasc, control = perm_design_dwarfscrub_nonvasc) #how many possible permutations 
          #base model 
          dwarfscrub_univariate_nonvasc_subclass <- adonis2(dwarfscrub_env_nonvasc$Species_Richness ~ Viereck.3 + 
                                                              Park + Plot + Sample_Year + Viereck.3*Sample_Year,
                                                   data = dwarfscrub_env_nonvasc, 
                                                   method = "euclidian",
                                                   permutations = perm_design_dwarfscrub_time_nonvasc,
                                                   by = "terms")
          print(dwarfscrub_univariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms023 <- rbind(1:nrow(dwarfscrub_env_nonvasc),
                           shuffleSet(n = nrow(dwarfscrub_env_nonvasc), 
                                      control = perm_design_dwarfscrub_nonvasc, nset = 999))
          
          #create object for SS to be stored 
          results023 <- matrix(nrow = nrow(perms023), ncol = 7)
          colnames(results023) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms023)) {
            temp.data <- dwarfscrub_env_nonvasc[perms023[i, ], ]
            temp <- adonis2(dwarfscrub_env_nonvasc$Species_Richness ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results023[i, ] <- t(temp$SumOfSqs)
          }
          
        #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results023 <- results023 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/13))
          head023 <- head(results023)
          print.data.frame(head023)
          #calculate P value 
          with(results023, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #create F value column - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results023 <- results023 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/2)/(Plot/13))
          head023 <- head(results023)
          print.data.frame(head023)
          #calculate P value 
          with(results023, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))


  ### Multivariate (Species frequency)
        #differences between parks 
          #base model 
          dwarfscrub_multivariate_nonvasc_park <- adonis2(dwarfscrub_composition_nonvasc ~ Park + Plot, 
                                               data = dwarfscrub_env_nonvasc, method = "bray", 
                                               permutations = perm_design_dwarfscrub_nonvasc, 
                                               by = "terms")
          print(dwarfscrub_multivariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms24 <- rbind(1:nrow(dwarfscrub_composition_nonvasc),
                           shuffleSet(n = nrow(dwarfscrub_composition_nonvasc), 
                                      control = perm_design_dwarfscrub_nonvasc, nset = 999))
          #head(perms18)
          results24 <- matrix(nrow = nrow(perms24), ncol = 4)
          colnames(results24) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms24)) {
            temp.data <- dwarfscrub_env_nonvasc[perms24[i, ], ]
            temp <- adonis2(dwarfscrub_composition_nonvasc ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results24[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results24 <- results24 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/14))
          head24 <- head(results24)
          print.data.frame(head24)
          #calculate P value 
          with(results24, sum(F.Park >= F.Park[1]) / length(F.Park))

    #differences between subclasses 
          #base model 
          dwarfscrub_multivariate_nonvasc_subclass <- adonis2(dwarfscrub_composition_nonvasc ~ Viereck.3 + Park + 
                                                                Plot + Sample_Year + Viereck.3*Sample_Year, 
                                               data = dwarfscrub_env_nonvasc, method = "bray", 
                                               permutations = perm_design_dwarfscrub_time_nonvasc, 
                                               by = "terms")
          print(dwarfscrub_multivariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms024 <- rbind(1:nrow(dwarfscrub_composition_nonvasc),
                           shuffleSet(n = nrow(dwarfscrub_composition_nonvasc), 
                                      control = perm_design_dwarfscrub_nonvasc, nset = 999))
          #head(perms18)
          results024 <- matrix(nrow = nrow(perms024), ncol = 7)
          colnames(results024) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms024)) {
            temp.data <- dwarfscrub_env_nonvasc[perms024[i, ], ]
            temp <- adonis2(dwarfscrub_composition_nonvasc ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results024[i, ] <- t(temp$SumOfSqs)
          }
          
        #calculate F statistic for park   - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results024 <- results024 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/13))
          head024 <- head(results024)
          print.data.frame(head024)
          #calculate P value 
          with(results024, sum(F.Park >= F.Park[1]) / length(F.Park))

        #calculate F statistic for viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results024 <- results024 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/2)/(Plot/13))
          head024 <- head(results024)
          print.data.frame(head024)
          #calculate P value 
          with(results024, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
                   
  #beta diversity 
        #park 
          dwarfscrub_dispersion_result_nonvasc <- betadisper(vegdist(dwarfscrub_composition_nonvasc, 
                                                                     method = "bray"), dwarfscrub_env_nonvasc$Park)
          dwarfscrub_dispersion_result_nonvasc 
          permutest(dwarfscrub_dispersion_result_nonvasc, permutations = 999)
          
        #based on visit 
          dwarfscrub_dispersion_result2_nonvasc <- betadisper(vegdist(dwarfscrub_composition_nonvasc, 
                                                                      method = "bray"), dwarfscrub_env_nonvasc$Visit)
          dwarfscrub_dispersion_result2_nonvasc
          permutest(dwarfscrub_dispersion_result2_nonvasc, permutations = 999)
          
        #based on viereck
          dwarfscrub_dispersion_result3_nonvasc <- betadisper(vegdist(dwarfscrub_composition_nonvasc, 
                                                                      method = "bray"), dwarfscrub_env_nonvasc$Viereck.3)
          dwarfscrub_dispersion_result3_nonvasc
          permutest(dwarfscrub_dispersion_result3_nonvasc, permutations = 999)


```

# Spruce Forest 

## Building the dataframes to be balanced, code for reference (not required to run if using quick load)
```{r}
#vascular 
    #hand select the years for plots with more than the decided number of visits
          filter_criteria_forest <- list(
            LACL_2013_01_S988	= c(2014, 2019),
            LACL_2013_01_S989	= c(2014, 2019),
            LACL_2013_01_S991	= c(2014, 2019),
            LACL_2010_01_S993	= c(2015, 2019),
            LACL_2010_01_S996	= c(2014, 2019),
            LACL_2010_01_S998	= c(2014, 2019),
            LACL_2010_01_S999	= c(2014, 2019))
          
          #next identify plots with two plot visits 
          forest_plots <- summary_table_vasc %>%
            filter(Viereck.2 == "Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(forest_plots, names(filter_criteria_forest))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
            filter(
              Plot %in% names(filter_criteria_forest) & 
                Sample_Year %in% unlist(filter_criteria_forest[Plot]))
          table(subset_hand_selected$Park, subset_hand_selected$Plot) 
          
          forest_df <- quad_abundance_df_vascular_filtered %>%
            filter(
              (Plot %in% forest_plots) | 
                (Plot %in% names(filter_criteria_forest) &
                   Sample_Year %in% unlist(filter_criteria_forest[Plot])))
          
          forest_df <- forest_df %>%
            left_join(viereck %>% select(Plot_Year, Viereck.3), by = c("Plot_Year"))
          
          forest_df <- forest_df %>%
            filter(Vegetation_Class != "Beetle kill spruce",
                   Viereck.3 != "Woodland Needleleaf Forest")
          
          table(forest_df$Park, forest_df$Plot) 
          
          forest_df <- forest_df[-7, ]
          
          #convert to frequency from PA
          forest_vasc_abundance_balanced <- vasc_abundance_df %>%
            filter(Plot_Year %in% forest_df$Plot_Year)
          forest_df <- forest_vasc_abundance_balanced
          
          
#Lichen 
        #hand select the years for plots with more than the decided number of visits
          filter_criteria_forest_lichens <- list(
            LACL_2013_01_S988	= c(2014, 2019),
            LACL_2013_01_S989	= c(2014, 2019),
            LACL_2013_01_S991	= c(2014, 2019),
            LACL_2010_01_S993	= c(2015, 2019),
            LACL_2010_01_S996	= c(2014, 2019),
            LACL_2010_01_S998	= c(2014, 2019),
            LACL_2010_01_S999	= c(2014, 2019))
          
          #next identify plots with two plot visits 
          forest_plots_lichens <- summary_table_lichens %>%
            filter(Viereck.2 == "Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(forest_plots_lichens, names(filter_criteria_forest_lichens))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected_lichens <- quad_abundance_df_lichen_filtered %>%
            filter(
              Plot %in% names(filter_criteria_forest_lichens) & 
                Sample_Year %in% unlist(filter_criteria_forest_lichens[Plot]))
          table(subset_hand_selected_lichens$Park, subset_hand_selected_lichens$Plot) 
          
          forest_df_lichens <- quad_abundance_df_lichen_filtered %>%
            filter(
              (Plot %in% forest_plots_lichens) | 
                (Plot %in% names(filter_criteria_forest_lichens) &
                   Sample_Year %in% unlist(filter_criteria_forest_lichens[Plot])))
          
          forest_df_lichens <- forest_df_lichens %>%
            filter(Vegetation_Class != "Beetle kill spruce",
                   Viereck.3 != "Woodland Needleleaf Forest")
          
          table(forest_df_lichens$Park, forest_df_lichens$Plot) 
          
          forest_df_lichens <- forest_df_lichens[-7, ]
          
          #convert to frequency from PA
          forest_lichen_abundance_balanced <- lichen_abundance_df %>%
            filter(Plot_Year %in% forest_df_lichen$Plot_Year)
          forest_df_lichens <- forest_lichen_abundance_balanced 
          
          
          
#nonvascular 
    #hand select the years for plots with more than the decided number of visits
          filter_criteria_forest_nonvasc <- list(
            LACL_2013_01_S988	= c(2014, 2019),
            LACL_2013_01_S989	= c(2014, 2019),
            LACL_2013_01_S991	= c(2014, 2019),
            LACL_2010_01_S993	= c(2015, 2019),
            LACL_2010_01_S996	= c(2014, 2019),
            LACL_2010_01_S998	= c(2014, 2019),
            LACL_2010_01_S999	= c(2014, 2019))
          
          #next identify plots with two plot visits 
          forest_plots_nonvasc <- summary_table_nonvasc %>%
            filter(Viereck.2 == "Needleleaf Forest", Number_Visits == 2) %>%
            pull(Plot)
          
          #combine plots with hand selected plots from filter criteria 
          selected_plots <- union(forest_plots_nonvasc, names(filter_criteria_forest_nonvasc))
          
          #subset main presence absence dataframe based on both conditions 
          #first verify that the hand selected plots were correctly pulled 
          subset_hand_selected_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              Plot %in% names(filter_criteria_forest_nonvasc) & 
                Sample_Year %in% unlist(filter_criteria_forest_nonvasc[Plot]))
          table(subset_hand_selected_nonvasc$Park, subset_hand_selected_nonvasc$Plot) 
          
          forest_df_nonvasc <- quad_abundance_df_nonvasc_filtered %>%
            filter(
              (Plot %in% forest_plots_nonvasc) | 
                (Plot %in% names(filter_criteria_forest_nonvasc) &
                   Sample_Year %in% unlist(filter_criteria_forest_nonvasc[Plot])))
          
          forest_df_nonvasc <- forest_df_nonvasc %>%
            filter(Vegetation_Class != "Beetle kill spruce",
                   Viereck.3 != "Woodland Needleleaf Forest")
          
          table(forest_df_nonvasc$Park, forest_df_nonvasc$Plot) 
          
          forest_df_nonvasc <- forest_df_nonvasc[-7, ]
          
          #convert to frequency from PA
          forest_nonvasc_abundance_balanced <- nonvasc_abundance_df %>%
            filter(Plot_Year %in% forest_df_nonvasc$Plot_Year)
          forest_nonvasc_df <- forest_nonvasc_abundance_balanced
```

## Creating the env files, code for reference (not required to run if using quick load)
```{r}
#Vascular 
          forest_env <- forest_df[,c(1:6)]
          
          #add visit column
          forest_env <- forest_env %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup() 
          #add species richness column
          forest_env <- forest_env %>%
            left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          #adding canopy cover 
          forest_env <- forest_env %>%
            left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
          forest_env <- forest_env %>% distinct()
          
#lichen 
          forest_env_lichen <- forest_df_lichen[,c(1:8)]
          
          #add visit column
          forest_env_lichen <- forest_env_lichen %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()
          #add species richness column
          forest_env_lichen <- forest_env_lichen %>%
            left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          #adding canopy cover 
          forest_env_lichen <- forest_env_lichen %>%
            left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
          forest_env_lichen <- forest_env_lichen %>% distinct()
          
#nonvascular 
          forest_env_nonvasc <- forest_df_nonvasc[,c(1:8)]
          
          #Add visit column
          forest_env_nonvasc <- forest_env_nonvasc %>%
            arrange(Plot, Sample_Year) %>%
            group_by(Plot) %>%
            mutate(Visit = paste0("visit_", row_number())) %>%
            ungroup()   
          #add species richness column
          forest_env_nonvasc <- forest_env_nonvasc %>%
            left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
          #adding canopy cover 
          forest_env_nonvasc <- forest_env_nonvasc %>%
            left_join(canopy_cover %>% select(Plot_Year, Percent_Cover), by = c("Plot_Year"))
          forest_env_nonvasc <- forest_env_nonvasc %>% distinct()
```


## Load Data Frames (Required)
```{r}
#quick load from T Drive 
forest_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_df_vasc_filtered.xlsx"))
forest_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_df_lichen_filtered.xlsx"))
forest_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_df_nonvasc_filtered.xlsx")) 
    
forest_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_env_vasc_filtered.xlsx"))
forest_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_env_lichen_filtered.xlsx"))
forest_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/forest_env_nonvasc_filtered.xlsx")) 

forest_env$Sample_Year <- as.numeric(forest_env$Sample_Year)
forest_env_lichen$Sample_Year <- as.numeric(forest_env_lichen$Sample_Year)
forest_env_nonvasc$Sample_Year <- as.numeric(forest_env_nonvasc$Sample_Year) 
```

## Calculate Species Richness Averages and Standard Error (Optional)
```{r}
#Spruce Forest 
        forest_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        forest_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        forest_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        forest_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        forest_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        forest_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))

```

## Create composition matrices, and restrict permutations for PERMANOVA (Required)
```{r}
#Vascular 
          forest_composition <- forest_df[,c(8:261)]
          forest_composition <- as.matrix(forest_composition) 
          
          #design permutation structure 
          perm_design_forest_time = how(
            plots = Plots(strata = forest_env$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          perm_design_forest = how(
            plots = Plots(strata = forest_env$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)

#Lichen 
          forest_composition_lichen <- forest_df_lichen[,c(10:167)]
          forest_composition_lichen <- as.matrix(forest_composition_lichen)

          #design permutation structure 
          perm_design_forest_time_lichen = how(
            plots = Plots(strata = forest_env_lichen$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          perm_design_forest_lichen = how(
            plots = Plots(strata = forest_env_lichen$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)

#Nonvascular 
          forest_composition_nonvasc <- forest_df_nonvasc[,c(10:210)]
          forest_composition_nonvasc <- as.matrix(forest_composition_nonvasc) 
          
          #design permutation structure 
          perm_design_forest_time_nonvasc = how(
            plots = Plots(strata = forest_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "series", mirror = FALSE),
            nperm = 999)
          perm_design_forest_nonvasc = how(
            plots = Plots(strata = forest_env_nonvasc$Plot, type = c("free")),
            within = Within(type = "none"),
            nperm = 999)
```


## Run PERMANOVA 
```{r}
#Vascular 
    #Univariate (species richness)
      #differences between parks 

          #base model
          forest_univariate_vasc_park <- adonis2(forest_env$Species_Richness ~ Park + Plot,
                                       data = forest_env, 
                                       method = "euclidian",
                                       permutations = perm_design_forest,
                                       by = "terms")
          print(forest_univariate_vasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms25 <- rbind(1:nrow(forest_env),
                           shuffleSet(n = nrow(forest_env), control = perm_design_forest, nset = 999))
          
          #create object for Ss to be stored 
          results25 <- matrix(nrow = nrow(perms25), ncol = 4)
          colnames(results25) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms25)) {
            temp.data <- forest_env[perms25[i, ], ]
            temp <- adonis2(forest_env$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results25[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results25 <- results25 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/23))
          head25 <- head(results25)
          print.data.frame(head25)
          #calculate P value 
          with(results25, sum(F.Park >= F.Park[1]) / length(F.Park))


      #differences between subclasses
          #base model
          forest_univariate_vasc_subclass <- adonis2(forest_env$Species_Richness ~ Viereck.3 + Park + 
                                                       Plot + Sample_Year + Viereck.3*Sample_Year,
                                       data = forest_env, 
                                       method = "euclidian",
                                       permutations = perm_design_forest_time,
                                       by = "terms")
          print(forest_univariate_vasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms025 <- rbind(1:nrow(forest_env),
                           shuffleSet(n = nrow(forest_env), control = perm_design_forest, nset = 999))
          
          #create object for Ss to be stored 
          results025 <- matrix(nrow = nrow(perms025), ncol = 7)
          colnames(results025) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms025)) {
            temp.data <- forest_env[perms025[i, ], ]
            temp <- adonis2(forest_env$Species_Richness ~ Viereck.3 + Park + Plot + Sample_Year + 
                              Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results025[i, ] <- t(temp$SumOfSqs)
          }
          
        #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results025 <- results025 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head025 <- head(results025)
          print.data.frame(head025)
          #calculate P value 
          with(results025, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #create F value column - viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results025 <- results025 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/22))
          head025 <- head(results025)
          print.data.frame(head025)
          #calculate P value 
          with(results025, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
          
    ### Multivariate - species frequency 
        #differences between parks 
          #base model 
          forest_multivariate_vasc_park <- adonis2(forest_composition ~ Park + Plot, 
                                   data = forest_env, method = "bray", 
                                   permutations = perm_design_forest, 
                                   by = "terms")
          print(forest_multivariate_vasc_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms26 <- rbind(1:nrow(forest_composition),
                           shuffleSet(n = nrow(forest_composition),
                                      control = perm_design_forest, nset = 999))
          results26 <- matrix(nrow = nrow(perms26), ncol = 7)
          colnames(results26) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                   "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms26)) {
            temp.data <- forest_env[perms26[i, ], ]
            temp <- adonis2(forest_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results26[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results26 <- results26 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/23))
          head26 <- head(results26)
          print.data.frame(head26)
          
          #calculate P value 
          with(results26, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          #rest of table 
          print(forest_multivariate_vasc_park)

          
    #differences between subclasses 
          #base model 
          forest_multivariate_vasc_subclass <- adonis2(forest_composition ~ Viereck.3 + Park + 
                                                         Plot + Sample_Year + Viereck.3*Sample_Year, 
                                   data = forest_env, method = "bray", 
                                   permutations = perm_design_forest_time, 
                                   by = "terms")
          print(forest_multivariate_vasc_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms026 <- rbind(1:nrow(forest_composition),
                           shuffleSet(n = nrow(forest_composition), control = perm_design_forest, nset = 999))
          results026 <- matrix(nrow = nrow(perms026), ncol = 7)
          colnames(results026) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms026)) {
            temp.data <- forest_env[perms026[i, ], ]
            temp <- adonis2(forest_composition ~ Viereck.3 + Park + Plot + Sample_Year + 
                              Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results026[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results026 <- results026 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head026 <- head(results026)
          print.data.frame(head026)
          #calculate P value 
          with(results026, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results026 <- results026 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/22))
          head026 <- head(results026)
          print.data.frame(head026)
          #calculate P value 
          with(results026, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          

  #Canopy Cover
        #Species Richness 
          forest_vascular_CC_univariate <- adonis2(forest_env$Species_Richness ~ 
                                                     Percent_Cover + Park + Plot + Sample_Year, 
                                            data = forest_env, method = "bray", 
                                            permutations = perm_design_forest_time, 
                                            by = "terms")
          print(forest_vascular_CC_univariate)
          
          
        #Species Frequency 
          forest_vascular_CC_multivariate <- adonis2(forest_composition ~ Percent_Cover + Park + 
                                                       Plot + Sample_Year, 
                                            data = forest_env, method = "bray", 
                                            permutations = perm_design_forest_time, 
                                            by = "terms")
          print(forest_vascular_CC_multivariate)
          
          
  #Beta Dispersion  
          
        #based on park 
          forest_dispersion_result <- betadisper(vegdist(forest_composition, 
                                                         method = "bray"), forest_env$Park)
          forest_dispersion_result 
          permutest(forest_dispersion_result, permutations = 999)
          
        #based on visit 
          forest_dispersion_result2 <- betadisper(vegdist(forest_composition, 
                                                          method = "bray"), forest_env$Visit)
          forest_dispersion_result2 
          permutest(forest_dispersion_result2, permutations = 999)
          
        #based on viereck
          forest_dispersion_result3 <- betadisper(vegdist(forest_composition, 
                                                          method = "bray"), forest_env$Viereck.3)
          forest_dispersion_result3 
          permutest(forest_dispersion_result3, permutations = 999)
          
          
----------------------------------------------------------------------------------------------------------------           
#Lichen 
  #Species Richness (Univariate)
    #differences between parks 
          #base model
          forest_univariate_lichen_park <- adonis2(forest_env_lichen$Species_Richness ~ Park + Plot,
                                               data = forest_env_lichen, 
                                               method = "euclidian",
                                               permutations = perm_design_forest_lichen,
                                               by = "terms")
          print(forest_univariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms27 <- rbind(1:nrow(forest_env_lichen),
                           shuffleSet(n = nrow(forest_env_lichen), control = perm_design_forest_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results27 <- matrix(nrow = nrow(perms27), ncol = 4)
          colnames(results27) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms27)) {
            temp.data <- forest_env_lichen[perms27[i, ], ]
            temp <- adonis2(forest_env_lichen$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results27[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results27 <- results27 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head27 <- head(results27)
          print.data.frame(head27)
          #calculate P value 
          with(results27, sum(F.Park >= F.Park[1]) / length(F.Park))
          
    #differences between subclasses 
          #base model
          forest_univariate_lichen_subclass <- adonis2(forest_env_lichen$Species_Richness ~ Viereck.3 + Park + 
                                                         Plot + Sample_Year + Viereck.3*Sample_Year,
                                               data = forest_env_lichen, 
                                               method = "euclidian",
                                               permutations = perm_design_forest_time_lichen,
                                               by = "terms")
          print(forest_univariate_lichen_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms027 <- rbind(1:nrow(forest_env_lichen),
                           shuffleSet(n = nrow(forest_env_lichen), 
                                      control = perm_design_forest_lichen, nset = 999))
          
          #create object for Ss to be stored 
          results027 <- matrix(nrow = nrow(perms027), ncol = 7)
          colnames(results027) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms027)) {
            temp.data <- forest_env_lichen[perms027[i, ], ]
            temp <- adonis2(forest_env_lichen$Species_Richness ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results027[i, ] <- t(temp$SumOfSqs)
          }
          
        #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results027 <- results027 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/21))
          head027 <- head(results027)
          print.data.frame(head027)
          #calculate P value 
          with(results027, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #create F value column - viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results027 <- results027 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/21))
          head027 <- head(results027)
          print.data.frame(head027)
          #calculate P value 
          with(results027, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

  ### Multivariate - Species Frequency 
        #differences between parks 
          #base model 
          forest_multivariate_lichen_park <- adonis2(forest_composition_lichen ~ Park + Plot, 
                                           data = forest_env_lichen, method = "bray", 
                                           permutations = perm_design_forest_lichen, 
                                           by = "terms")
          print(forest_multivariate_lichen_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms28 <- rbind(1:nrow(forest_composition_lichen),
                           shuffleSet(n = nrow(forest_composition_lichen), control = perm_design_forest_lichen, nset = 999))
          results28 <- matrix(nrow = nrow(perms28), ncol = 4)
          colnames(results28) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms28)) {
            temp.data <- forest_env_lichen[perms28[i, ], ]
            temp <- adonis2(forest_composition_lichen ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results28[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results28 <- results28 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head28 <- head(results28)
          print.data.frame(head28)
          #calculate P value 
          with(results28, sum(F.Park >= F.Park[1]) / length(F.Park))
          
          
    #Differences between Subclasses 
          #base model 
          forest_multivariate_lichen_subclass <- adonis2(forest_composition_lichen ~ Viereck.3 + Park + 
                                                           Plot + Sample_Year + Viereck.3*Sample_Year, 
                                           data = forest_env_lichen, method = "bray", 
                                           permutations = perm_design_forest_time_lichen, 
                                           by = "terms")
          print(forest_multivariate_lichen_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms028 <- rbind(1:nrow(forest_composition_lichen),
                           shuffleSet(n = nrow(forest_composition_lichen), 
                                      control = perm_design_forest_lichen, nset = 999))
          results028 <- matrix(nrow = nrow(perms028), ncol = 7)
          colnames(results028) <- c("Viereck.3", "Park", "Plot", 
                                    "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms028)) {
            temp.data <- forest_env_lichen[perms028[i, ], ]
            temp <- adonis2(forest_composition_lichen ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results028[i, ] <- t(temp$SumOfSqs)
          }
          
        #calculate F statistic for park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results028 <- results028 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/21))
          head028 <- head(results028)
          print.data.frame(head028)
          #calculate P value 
          with(results028, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #calculate F statistic for viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results028 <- results028 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/21))
          head028 <- head(results028)
          print.data.frame(head028)
          #calculate P value 
          with(results028, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
    #Canopy Cover
        #Species Richness 
          forest_lichen_CC_univariate <- adonis2(forest_env_lichen$Species_Richness ~ Percent_Cover + Park + Plot + Sample_Year, 
                                            data = forest_env_lichen, method = "bray", 
                                            permutations = perm_design_forest_time_lichen, 
                                            by = "terms")
          print(forest_lichen_CC_univariate)
          
        #Species Frequency 
          forest_lichen_CC_multivariate <- adonis2(forest_composition_lichen ~ Percent_Cover + Park + Plot + Sample_Year, 
                                            data = forest_env_lichen, method = "bray", 
                                            permutations = perm_design_forest_time_lichen, 
                                            by = "terms")
          print(forest_lichen_CC_multivariate)          
          
  #Beta Dispersion  
          
        #based on park 
          forest_dispersion_result_lichen <- betadisper(vegdist(forest_composition_lichen, 
                                                                 method = "bray"), forest_env_lichen$Park)
          forest_dispersion_result_lichen 
          permutest(forest_dispersion_result_lichen, permutations = 999)
          
        #based on visit 
          forest_dispersion_result2_lichen <- betadisper(vegdist(forest_composition_lichen, 
                                                                  method = "bray"), forest_env_lichen$Visit)
          forest_dispersion_result2_lichen 
          permutest(forest_dispersion_result2_lichen, permutations = 999)
          
        #viereck 
          forest_dispersion_result3_lichen <- betadisper(vegdist(forest_composition_lichen, 
                                                                  method = "bray"), forest_env_lichen$Viereck.3)
          forest_dispersion_result3_lichen 
          permutest(forest_dispersion_result3_lichen, permutations = 999)

          
          
----------------------------------------------------------------------------------------------------------------           
          
#Nonvascular 
  #Species Richness (Univariate)
      #differences between parks 
          #base model 
          forest_univariate_nonvasc_park <- adonis2(forest_env_nonvasc$Species_Richness ~ Park + Plot,
                                               data = forest_env_nonvasc, 
                                               method = "euclidian",
                                               permutations = perm_design_forest_nonvasc,
                                               by = "terms")
          print(forest_univariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms29 <- rbind(1:nrow(forest_env_nonvasc),
                           shuffleSet(n = nrow(forest_env_nonvasc), control = perm_design_forest_nonvasc, nset = 999))
          
          #create object for SS to be stored 
          results29 <- matrix(nrow = nrow(perms29), ncol = 4)
          colnames(results29) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms29)) {
            temp.data <- forest_env_nonvasc[perms29[i, ], ]
            temp <- adonis2(forest_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results29[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results29 <- results29 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head29 <- head(results29)
          print.data.frame(head29)
          #calculate P value 
          with(results29, sum(F.Park >= F.Park[1]) / length(F.Park))
          
       #differences between subclasses
          #base model 
          forest_univariate_nonvasc_subclass <- adonis2(forest_env_nonvasc$Species_Richness ~ Viereck.3 + Park + 
                                                          Plot + Sample_Year + Viereck.3*Sample_Year,
                                               data = forest_env_nonvasc, 
                                               method = "euclidian",
                                               permutations = perm_design_forest_time_nonvasc,
                                               by = "terms")
          print(forest_univariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms029 <- rbind(1:nrow(forest_env_nonvasc),
                           shuffleSet(n = nrow(forest_env_nonvasc), 
                                      control = perm_design_forest_nonvasc, nset = 999))
          
          #create object for SS to be stored 
          results029 <- matrix(nrow = nrow(perms029), ncol = 7)
          colnames(results029) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms029)) {
            temp.data <- forest_env_nonvasc[perms029[i, ], ]
            temp <- adonis2(forest_env_nonvasc$Species_Richness ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results029[i, ] <- t(temp$SumOfSqs)
          }
          
        #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results029 <- results029 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/21))
          head029 <- head(results029)
          print.data.frame(head029)
          #calculate P value 
          with(results029, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #create F value column - viereck - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results029 <- results029 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/21))
          head029 <- head(results029)
          print.data.frame(head029)
          #calculate P value 
          with(results029, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

          
    ### Multivariate - Species Frequency  
        #differences between parks
          #base model
          forest_result_nonvasc_park <- adonis2(forest_composition_nonvasc ~ Park + Plot, 
                                           data = forest_env_nonvasc, method = "bray", 
                                           permutations = perm_design_forest_nonvasc, 
                                           by = "terms")
          print(forest_multivariate_nonvasc_park)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms30 <- rbind(1:nrow(forest_composition_nonvasc),
                           shuffleSet(n = nrow(forest_composition_nonvasc), 
                                      control = perm_design_forest_nonvasc, nset = 999))
          results30 <- matrix(nrow = nrow(perms30), ncol = 4)
          colnames(results30) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms30)) {
            temp.data <- forest_env_nonvasc[perms30[i, ], ]
            temp <- adonis2(forest_composition_nonvasc ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results30[i, ] <- t(temp$SumOfSqs)
          }
          
          #calculate F statistics for each permutation using correct equation  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results30 <- results30 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/22))
          head30 <- head(results30)
          print.data.frame(head30)
          #calculate P value 
          with(results30, sum(F.Park >= F.Park[1]) / length(F.Park))
          
    #differences between subclasses 
          #base model
          forest_multivariate_nonvasc_subclass <- adonis2(forest_composition_nonvasc ~ Viereck.3 + Park + 
                                                      Plot + Sample_Year + Viereck.3*Sample_Year, 
                                           data = forest_env_nonvasc, method = "bray", 
                                           permutations = perm_design_forest_time_nonvasc, 
                                           by = "terms")
          print(forest_multivariate_nonvasc_subclass)
          
          #hand calculate corrected F values
          #create permutation structure and results object 
          perms030 <- rbind(1:nrow(forest_composition_nonvasc),
                           shuffleSet(n = nrow(forest_composition_nonvasc), 
                                      control = perm_design_forest_nonvasc, nset = 999))
          results030 <- matrix(nrow = nrow(perms030), ncol = 7)
          colnames(results030) <- c("Viereck.3", "Park", "Plot", "Sample_Year", 
                                    "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms030)) {
            temp.data <- forest_env_nonvasc[perms030[i, ], ]
            temp <- adonis2(forest_composition_nonvasc ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results030[i, ] <- t(temp$SumOfSqs)
          }
          
        #calculate F statistic for park - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results030 <- results030 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/21))
          head030 <- head(results030)
          print.data.frame(head030)
          #calculate P value 
          with(results030, sum(F.Park >= F.Park[1]) / length(F.Park))
          
        #calculate F statistic for viereck - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results030 <- results030 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/1)/(Plot/21))
          head030 <- head(results030)
          print.data.frame(head030)
          #calculate P value 
          with(results030, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
      

          
    #Canopy Cover models 
        #Species Richness 
          forest_nonvasc_CC_univariate <- adonis2(forest_env_nonvasc$Species_Richness ~ 
                                                    Percent_Cover + Park + Plot + Sample_Year, 
                                            data = forest_env_nonvasc, method = "bray", 
                                            permutations = perm_design_forest_time_nonvasc, 
                                            by = "terms")
          print(forest_nonvasc_CC_univariate)

        #Species Frequency 
          forest_nonvasc_CC_multivariate <- adonis2(forest_composition_nonvasc ~ 
                                                      Percent_Cover + Park + Plot + Sample_Year, 
                                            data = forest_env_nonvasc, method = "bray", 
                                            permutations = perm_design_forest_time_nonvasc, 
                                            by = "terms")
          print(forest_nonvasc_CC_multivariate) 
          
          
    #Beta Dispersion 
          
        #based on park 
          forest_dispersion_result_nonvasc <- betadisper(vegdist(forest_composition_nonvasc, 
                                                                 method = "bray"), forest_env_nonvasc$Park)
          forest_dispersion_result_nonvasc 
          permutest(forest_dispersion_result_nonvasc, permutations = 999)
          
        #based on visit 
          forest_dispersion_result2_nonvasc <- betadisper(vegdist(forest_composition_nonvasc, 
                                                                  method = "bray"), forest_env_nonvasc$Visit)
          forest_dispersion_result2_nonvasc 
          permutest(forest_dispersion_result2_nonvasc, permutations = 999)
          
        #viereck 
          forest_dispersion_result3_nonvasc <- betadisper(vegdist(forest_composition_nonvasc, 
                                                                  method = "bray"), forest_env_nonvasc$Viereck.3)
          forest_dispersion_result3_nonvasc 
          permutest(forest_dispersion_result3_nonvasc, permutations = 999)
```




# Alpine Communities 

## Building the dataframes to be balanced - code for reference (not required to run if using quick load)
```{r}
#vascular 
    #code for building the above dataframe 
            filter_criteria_alpine <- list(
              KATM_2009_02_048 = c(2011, 2016, 2023),
              KATM_2010_03_049 = c(2011, 2016, 2023),
              LACL_2010_03_001 = c(2011, 2016, 2023))
            
            #identify alpine plots with three plot visits 
            alpine_plots <- summary_table_vasc %>%
              filter(Vegetation_Class == "Alpine", Number_Visits == 3) %>%
              pull(Plot)
            
            #combine alpine plots with hand selected plots from filter criteria 
            selected_plots <- union(alpine_plots, names(filter_criteria_alpine))
            
            #subset main presence absence dataframe based on both conditions 
            
            #but first verify that the hand selected plots were correctly pulled 
            subset_hand_selected <- quad_abundance_df_vascular_filtered %>%
              filter(
                Plot %in% names(filter_criteria_alpine) & 
                  Sample_Year %in% unlist(filter_criteria_alpine[Plot]))
            
            alpine_df <- quad_abundance_df_vascular_filtered %>%
              filter(
                (Plot %in% alpine_plots) | 
                  (Plot %in% names(filter_criteria_alpine) &
                     Sample_Year %in% unlist(filter_criteria_alpine[Plot])))
            
            
#lichen 
      #hand select plots with high number of visits 
      filter_criteria_alpine_lichen <- list(
        LACL_2010_03_998 = c(2011, 2016))
      
      #next identify plots with two plot visits 
      alpine_lichen_plots <- summary_table_lichens %>%
        filter(Vegetation_Class == "Alpine", Number_Visits == 2) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(alpine_lichen_plots, names(filter_criteria_alpine_lichen))
      selected_plots
      #subset main presence absence dataframe based on both conditions 
      #first verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_lichen_filtered %>%
        filter(
          Plot %in% names(filter_criteria_alpine_lichen) & 
            Sample_Year %in% unlist(filter_criteria_alpine_lichen[Plot]))
      table(subset_hand_selected$Park, subset_hand_selected$Plot) 
      
      alpine_lichen_df <- quad_abundance_df_lichen_filtered %>%
        filter(
          (Plot %in% alpine_lichen_plots) | 
            (Plot %in% names(filter_criteria_alpine_lichen) &
               Sample_Year %in% unlist(filter_criteria_alpine_lichen[Plot])))
      
      #verify everything has two sample visits 
      table(alpine_lichen_df$Park, alpine_lichen_df$Plot)



#nonvascular 
      #hand select plots with high number of visits 
      filter_criteria_alpine_nonvasc <- list(
        LACL_2010_03_998 = c(2011, 2016))
      
      #next identify plots with two plot visits 
      alpine_nonvasc_plots <- summary_table_nonvasc %>%
        filter(Vegetation_Class == "Alpine", Number_Visits == 2) %>%
        pull(Plot)
      
      #combine plots with hand selected plots from filter criteria 
      selected_plots <- union(alpine_nonvasc_plots, names(filter_criteria_alpine_nonvasc))
      selected_plots
      #subset main presence absence dataframe based on both conditions 
      #first verify that the hand selected plots were correctly pulled 
      subset_hand_selected <- quad_abundance_df_nonvasc_filtered %>%
        filter(
          Plot %in% names(filter_criteria_alpine_nonvasc) & 
            Sample_Year %in% unlist(filter_criteria_alpine_nonvasc[Plot]))
      table(subset_hand_selected$Park, subset_hand_selected$Plot) 
      
      alpine_nonvasc_df <- quad_abundance_df_nonvasc_filtered %>%
        filter(
          (Plot %in% alpine_nonvasc_plots) | 
            (Plot %in% names(filter_criteria_alpine_nonvasc) &
               Sample_Year %in% unlist(filter_criteria_alpine_nonvasc[Plot])))
      
      #verify everything has two sample visits 
      table(alpine_nonvasc_df$Park, alpine_nonvasc_df$Plot)

```

## Creating the env files, code for reference (not required to run if using quick load)
```{r}
#Vascular 
            alpine_env <- alpine_df[,c(1:6)]
            
            #Add species richness column 
            alpine_env <- alpine_env %>%
              left_join(vasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
            
            #Add visit column for beta diversity 
            alpine_env <- alpine_env %>%
              arrange(Plot, Sample_Year) %>%
              group_by(Plot) %>%
              mutate(Visit = paste0("visit_", row_number())) %>%
              ungroup()
            
#Lichen 
            alpine_env_lichen <- alpine_df_lichen[,c(1:8)]

            #Add species richness column 
            alpine_env_lichen <- alpine_env_lichen %>%
              left_join(lichen_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
            
            #Add visit column for beta diversity 
            alpine_env_lichen <- alpine_env_lichen %>%
              arrange(Plot, Sample_Year) %>%
              group_by(Plot) %>%
              mutate(Visit = paste0("visit_", row_number())) %>%
              ungroup()


#Nonvascular 

            alpine_env_nonvasc <- alpine_df_nonvasc[,c(1:8)]
            
            #Add visit column for beta diversity 
            alpine_env_nonvasc <- alpine_env_nonvasc %>%
              arrange(Plot, Sample_Year) %>%
              group_by(Plot) %>%
              mutate(Visit = paste0("visit_", row_number())) %>%
              ungroup()
            
            #Add species richness column 
            alpine_env_nonvasc <- alpine_env_nonvasc %>%
              left_join(nonvasc_sp_richness %>% select(Plot_Year, Species_Richness), by = c("Plot_Year"))
```

## Load Data Frames (Required)
```{r}
alpine_df <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_df_vasc_filtered.xlsx"))
alpine_df_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_df_lichen_filtered.xlsx"))
alpine_df_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_df_nonvasc_filtered.xlsx"))

alpine_env <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_env_vasc_filtered.xlsx"))
alpine_env_lichen <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_env_lichen_filtered.xlsx"))
alpine_env_nonvasc <- read_xlsx(here("Data/Modified/Collapsed_Species_Code_DFs/PERMANOVA_DF_QuickLoad/alpine_env_nonvasc_filtered.xlsx"))

#Ensure that sample year is numeric 
alpine_env$Sample_Year <- as.numeric(alpine_env$Sample_Year)
alpine_env_lichen$Sample_Year <- as.numeric(alpine_env_lichen$Sample_Year)
alpine_env_nonvasc$Sample_Year <- as.numeric(alpine_env_nonvasc$Sample_Year) 
```

## Calculate Species Richness Averages and Standard Error (Optional) 
```{r}
        alpine_env %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        alpine_env %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        alpine_env_lichen %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        alpine_env_lichen %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        alpine_env_nonvasc %>%
          group_by(Park) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
        
        alpine_env_nonvasc %>%
          group_by(Visit) %>%
          summarise(
            mean_richness = mean(Species_Richness, na.rm = TRUE),
            se_richness = sd(Species_Richness, na.rm = TRUE)/sqrt(n()))
```

## Create composition matrices, and restrict permutations for PERMANOVA (Required)
```{r}
#Create species matrices 
      alpine_composition <- alpine_df[,c(8:261)]
      alpine_composition <- as.matrix(alpine_composition) 
          
      alpine_lichen_composition <- alpine_df_lichen[,c(10:167)]
      alpine_lichen_composition <- as.matrix(alpine_lichen_composition) 
          
      alpine_nonvasc_composition <- alpine_df_nonvasc[,c(10:210)]
      alpine_nonvasc_composition <- as.matrix(alpine_nonvasc_composition) 


#Restrict Permutations 

#Vascular 
      #for differences between parks  
            perm_design_alpine = how(
              plots = Plots(strata = alpine_env$Plot, type = c("free")),
              within = Within(type = "none"),
              nperm = 999)
      #for differences over time 
            perm_design_alpine_time = how(
              plots = Plots(strata = alpine_env$Plot, type = c("free")),
              within = Within(type = "series", mirror = FALSE),
              nperm = 999)
            
            
#Lichen 
      #for differences between parks
            perm_design_alpine_lichen = how(
              plots = Plots(strata = alpine_env_lichen$Plot, type = c("free")),
              within = Within(type = "none"),
              nperm = 999)
      #for differences over time   
            perm_design_alpine_lichen_time = how(
              plots = Plots(strata = alpine_env_lichen$Plot, type = c("free")),
              within = Within(type = "series", mirror = FALSE),
              nperm = 999)
            

#Nonvascular 
      #for differences between parks
            perm_design_alpine_nonvasc = how(
              plots = Plots(strata = alpine_env_nonvasc$Plot, type = c("free")),
              within = Within(type = "none"),
              nperm = 999)
      #for differences over time 
            perm_design_alpine_nonvasc_time = how(
              plots = Plots(strata = alpine_env_nonvasc$Plot, type = c("free")),
              within = Within(type = "series", mirror = FALSE),
              nperm = 999)
```

## Run PERMANOVA 
```{r}
## Vascular 

#Species Richness (Univariate)
      #Differences between Parks 
        #base model
          alpine_univariate_vasc_park <- adonis2(alpine_env$Species_Richness ~ Park + Plot,
                                     data = alpine_env, 
                                     method = "euclidian",
                                     permutations = perm_design_alpine,
                                     by = "terms")
          print(alpine_univariate_vasc_park)
          
          #hand calculate corrected F values
        #create permutation framework + results object 
          perms31 <- rbind(1:nrow(alpine_env),
                         shuffleSet(n = nrow(alpine_env), control = perm_design_alpine, nset = 999))
          results31 <- matrix(nrow = nrow(perms31), ncol = 4)
          colnames(results31) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
          for (i in 1:nrow(perms31)) {
            temp.data <- alpine_env[perms31[i, ], ]
            temp <- adonis2(alpine_env$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results31[i, ] <- t(temp$SumOfSqs)
          }
          
      #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results31 <- results31 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/15))
          head(results31) #top row has term F statistic for model 
      #calculate P value 
          with(results31, sum(F.Park >= F.Park[1]) / length(F.Park))
        
          
  #Differences between subclasses 
      #base model 
          alpine_univariate_vasc_subclass <- adonis2(alpine_env$Species_Richness ~ Viereck.3 + Park + 
                                                    Plot + Sample_Year + Viereck.3*Sample_Year,
                                     data = alpine_env, 
                                     method = "euclidian",
                                     permutations = perm_design_alpine_time,
                                     by = "terms")
          print(alpine_univariate_vasc_subclass)
          
          #hand calculate corrected F values
      #create permutation framework + results object 
          perms32 <- rbind(1:nrow(alpine_env),
                         shuffleSet(n = nrow(alpine_env), 
                                    control = perm_design_alpine, nset = 999))
          results32 <- matrix(nrow = nrow(perms32), ncol = 7)
          colnames(results32) <- c("Viereck.3", "Park", "Plot", 
                                   "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms32)) {
            temp.data <- alpine_env[perms32[i, ], ]
            temp <- adonis2(alpine_env$Species_Richness ~ Viereck.3 + Park + 
                                                    Plot + Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results32[i, ] <- t(temp$SumOfSqs)
          }
          
      #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results32 <- results32 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head(results32) #top row has term F statistic for model 
      #calculate P value 
          with(results32, sum(F.Park >= F.Park[1]) / length(F.Park))

      #create F value column - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results32 <- results32 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/3)/(Plot/12))
          head32 <- head(results32)
          print.data.frame(head32) #top row has term F statistic for model 
      #calculate P value 
          with(results32, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
          
#Multivariate (Species Frequency) 
    #Differences between parks 
        #base model 
          alpine_multivariate_vasc_park <- adonis2(alpine_composition ~ Park + Plot, 
                       data = alpine_env, method = "bray", 
                       permutations = perm_design_alpine, 
                       by = "terms")
          print(alpine_multivariate_vasc_park)
          
          #hand calculate corrected F values
    #create permutation framework + results object 
          perms33 <- rbind(1:nrow(alpine_composition),
                shuffleSet(n = nrow(alpine_composition), control = perm_design_alpine, nset = 999))
          results33 <- matrix(nrow = nrow(perms33), ncol = 4)
          colnames(results33) <- c("Park", "Plot", "Residual", "Total")

      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms33)) {
            temp.data <- alpine_env[perms33[i, ], ]
            temp <- adonis2(alpine_composition ~ Park + Plot,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results33[i, ] <- t(temp$SumOfSqs)
          }
          
    #calculate F values for permutations  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results33 <- results33 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/15))
          head(results33)
    #calculate P value 
          with(results33, sum(F.Park >= F.Park[1]) / length(F.Park))
          print(alpine_multivariate_vasc_park)
      
          
          
  #Differences between subclasses 
      #Base model 
          alpine_multivariate_vasc_subclass <- adonis2(alpine_composition ~ Viereck.3 + Park + Plot + 
                                            Sample_Year + Viereck.3*Sample_Year, 
                       data = alpine_env, method = "bray", 
                       permutations = perm_design_alpine_time, 
                       by = "terms")
          print(alpine_multivariate_vasc_subclass)
          
          #hand calculate corrected F values
      #create permutation framework + results object 
          perms34 <- rbind(1:nrow(alpine_composition),
                shuffleSet(n = nrow(alpine_composition), 
                           control = perm_design_alpine, nset = 999))
          results34 <- matrix(nrow = nrow(perms34), ncol = 7)
          colnames(results34) <- c("Viereck.3", "Park", "Plot", 
                                   "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")

      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms34)) {
            temp.data <- alpine_env[perms34[i, ], ]
            temp <- adonis2(alpine_composition ~ Viereck.3 + Park + Plot + 
                                            Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "bray",
                            by = "terms",
                            permutations = 0)
            results34[i, ] <- t(temp$SumOfSqs)
          }
          
      #calculate F values for permutations - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results34 <- results34 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head34 <- head(results34)
          print.data.frame(head34)
      #calculate P value 
          with(results34, sum(F.Park >= F.Park[1]) / length(F.Park))
          
      #calculate F values for permutations - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results34 <- results34 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/3)/(Plot/12))
          head34 <- head(results34)
          print.data.frame(head34)
      #calculate P value 
          with(results34, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))
 
#beta diversity 

      #based on park 
          alpine_dispersion_result <- betadisper(vegdist(alpine_composition, 
                                      method = "bray"), alpine_env$Park)
          alpine_dispersion_result 
          permutest(alpine_dispersion_result, permutations = 999)
          
      #based on visit 
          alpine_dispersion_result2 <- betadisper(vegdist(alpine_composition, 
                                       method = "bray"), alpine_env$Visit)
          alpine_dispersion_result2 
          permutest(alpine_dispersion_result2, permutations = 999)
          
      #based on viereck 
          alpine_dispersion_result3 <- betadisper(vegdist(alpine_composition, 
                                       method = "bray"), alpine_env$Viereck.3)
          alpine_dispersion_result3 
          permutest(alpine_dispersion_result3, permutations = 999)

----------------------------------------------------------------------------------------------------------------               
## Lichen 

### Univariate (Species Richness)
         #difference between parks  
              #Base Model 
                alpine_lichen_univariate_park <- adonis2(alpine_env_lichen$Species_Richness ~ Park + Plot,
                                           data = alpine_env_lichen, 
                                           method = "euclidian",
                                           permutations = perm_design_alpine_lichen,
                                           by = "terms")
                print(alpine_lichen_univariate_park)
                
                #hand calculate corrected F values
                #create permutation object 
                perms35 <- rbind(1:nrow(alpine_env_lichen),
                               shuffleSet(n = nrow(alpine_env_lichen), control = perm_design_alpine_lichen, nset = 999))
                
                #create object for Ss to be stored 
                results35 <- matrix(nrow = nrow(perms35), ncol = 4)
                colnames(results35) <- c("Park", "Plot", "Residual", "Total")
                
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
                for (i in 1:nrow(perms35)) {
                  temp.data <- alpine_env_lichen[perms35[i, ], ]
                  temp <- adonis2(alpine_env_lichen$Species_Richness ~ Park + Plot,
                                  data = temp.data,
                                  method = "euclidian",
                                  by = "terms",
                                  permutations = 0)
                  results35[i, ] <- t(temp$SumOfSqs)
                }
                
                #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results35 <- results35 |>
                  data.frame() |>
                  mutate(F.Park = (Park/1)/(Plot/14))
                head35 <- head(results35)
                print.data.frame(head35) #first row is observed/your data, rows 2-1000 are the permuted data 
                #calculate P value 
                with(results35, sum(F.Park >= F.Park[1]) / length(F.Park))
                print(alpine_lichen_univariate_park)

                
    #Differences between subclasses 
              #Base Model
                alpine_lichen_univariate_subclass <- adonis2(alpine_env_lichen$Species_Richness ~ Viereck.3 + 
                                                      Park + Plot + Sample_Year + Viereck.3*Sample_Year,
                                           data = alpine_env_lichen, 
                                           method = "euclidian",
                                           permutations = perm_design_alpine_lichen_time,
                                           by = "terms")
                print(alpine_lichen_univariate_subclass)
                
                #hand calculate corrected F values
                #create permutation object 
                perms36 <- rbind(1:nrow(alpine_env_lichen),
                               shuffleSet(n = nrow(alpine_env_lichen), 
                                          control = perm_design_alpine_lichen, nset = 999))
                
                #create object for Ss to be stored 
                #remove park because it is auto-dropped by adonis 
                results36 <- matrix(nrow = nrow(perms36), ncol = 6)
                colnames(results36) <- c("Viereck.3", "Plot", "Sample_Year", 
                                        "Viereck.3*Sample_Year", "Residual", "Total")
                
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe  
                for (i in 1:nrow(perms36)) {
                  temp.data <- alpine_env_lichen[perms36[i, ], ]
                  temp <- adonis2(alpine_env_lichen$Species_Richness ~ Viereck.3 + Park + 
                                    Plot + Sample_Year + Viereck.3*Sample_Year,
                                  data = temp.data,
                                  method = "euclidian",
                                  by = "terms",
                                  permutations = 0)
                  results36[i, ] <- t(temp$SumOfSqs)
                }
                
            #create F value column - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results36 <- results36 |>
                  data.frame() |>
                  mutate(F.Park = (Park/1)/(Plot/12))
                head36 <- head(results36)
                print.data.frame(head36)
                #first row is observed/your data, rows 2-1000 are the permuted data 
                #calculate P value 
                with(results36, sum(F.Park >= F.Park[1]) / length(F.Park))                
                
            #create F value column - viereck  - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results36 <- results36 |>
                  data.frame() |>
                  mutate(F.Viereck = (Viereck.3/4)/(Plot/12))
                head36 <- head(results36)
                print.data.frame(head36)
                #first row is observed/your data, rows 2-1000 are the permuted data 
                #calculate P value 
                with(results36, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck)) 

### Multivariate - presence absence composition 

      #Differences between parks 
              #Base Model 
                alpine_lichen_multivariate_park <- adonis2(alpine_lichen_composition ~ Park + Plot, 
                                       data = alpine_env_lichen, method = "bray", 
                                       permutations = perm_design_alpine_lichen, 
                                       by = "terms")
                print(alpine_lichen_multivariate_park)
                
                #hand calculate corrected F values
                #create permutation object 
                perms37 <- rbind(1:nrow(alpine_lichen_composition),
                                shuffleSet(n = nrow(alpine_lichen_composition), 
                                           control = perm_design_alpine_lichen, nset = 999))
                
                results37 <- matrix(nrow = nrow(perms37), ncol = 4)
                colnames(results37) <- c("Park", "Plot", "Residual", "Total")
                
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
                for (i in 1:nrow(perms37)) {
                  temp.data <- lichens_env_alpine[perms37[i, ], ]
                  temp <- adonis2(alpine_lichen_composition ~ Park + Plot,
                                  data = temp.data,
                                  method = "bray",
                                  by = "terms",
                                  permutations = 0)
                  results37[i, ] <- t(temp$SumOfSqs)
                }
                
                #calculate F values for permutations  - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results37 <- results37 |>
                  data.frame() |>
                  mutate(F.Park = (Park/1)/(Plot/14))
                head37 <- head(results37)
                print.data.frame(head37)
                #calculate P value 
                with(results37, sum(F.Park >= F.Park[1]) / length(F.Park))
                print(alpine_lichen_multivariate_park)


      #subclass model 
              #Base model 
                alpine_lichen_multivariate_subclass <- adonis2(alpine_lichen_composition ~ Viereck.3 + Park + 
                                                  Plot + Sample_Year + Viereck.3*Sample_Year, 
                                       data = alpine_env_lichen, method = "bray", 
                                       permutations = perm_design_alpine_lichen_time, 
                                       by = "terms")
                print(alpine_lichen_multivariate_subclass)
                
                #hand calculate corrected F values
                #create permutation object 
                perms38 <- rbind(1:nrow(alpine_lichen_composition),
                                shuffleSet(n = nrow(alpine_lichen_composition), 
                                           control = perm_design_alpine_lichen, nset = 999))
                
                results38 <- matrix(nrow = nrow(perms38), ncol = 6)
                colnames(results38) <- c("Viereck.3", "Plot", "Sample_Year", 
                                                        "Viereck.3*Sample_Year", "Residual", "Total")
                
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
                for (i in 1:nrow(perms38)) {
                  temp.data <- alpine_env_lichen[perms38[i, ], ]
                  temp <- adonis2(alpine_lichen_composition ~ Viereck.3 + 
                                    Park + Plot + Sample_Year + Viereck.3*Sample_Year,
                                  data = temp.data,
                                  method = "bray",
                                  by = "terms",
                                  permutations = 0)
                  results38[i, ] <- t(temp$SumOfSqs)
                }
                
              #calculate F values for permutations - park  - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results38 <- results38 |>
                  data.frame() |>
                  mutate(F.Park = (Park/1)/(Plot/12))
                head(results38)
                #calculate P value 
                with(results38, sum(F.Park >= F.Park[1]) / length(F.Park))
                
              #calculate F values for permutations - subclass - make sure to use the correct Degree of freedom values in the numerator and denominator 
                results38 <- results38 |>
                  data.frame() |>
                  mutate(F.Viereck = (Viereck.3/4)/(Plot/12))
                head38 <- head(results38)
                print.data.frame(head38)
                #calculate P value 
                with(results38, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

#Beta Dispersion 

      #based on park 
            alpine_lichen_dispersion_result <- betadisper(vegdist(alpine_lichen_composition, 
                                                         method = "bray"), alpine_env_lichen$Park)
            alpine_lichen_dispersion_result 
            permutest(alpine_lichen_dispersion_result, permutations = 999)
      
      #based on visit 
            alpine_lichen_dispersion_result2 <- betadisper(vegdist(alpine_lichen_composition, 
                                                         method = "bray"), alpine_env_lichen$Visit)
            alpine_lichen_dispersion_result2 
            permutest(alpine_lichen_dispersion_result2, permutations = 999)
      
      #based on viereck
            alpine_lichen_dispersion_result3 <- betadisper(vegdist(alpine_lichen_composition, 
                                                         method = "bray"), alpine_env_lichen$Viereck.3)
            alpine_lichen_dispersion_result3 
            permutest(alpine_lichen_dispersion_result3, permutations = 999)

---------------------------------------------------------------------------------------------------------------------------

## Nonvascular
              
  ### Univariate (Species Richness)

      #Differences between Parks 
        #Base model 
          alpine_nonvasc_univariate_park <- adonis2(alpine_env_nonvasc$Species_Richness ~ Park + Plot,
                                              data = alpine_env_nonvasc, 
                                              method = "euclidian",
                                              permutations = perm_design_alpine_nonvasc,
                                              by = "terms")
          print(alpine_nonvasc_univariate_park)
          
          #hand calculate corrected F values
          #create permutation object 
          perms39 <- rbind(1:nrow(alpine_env_nonvasc),
                         shuffleSet(n = nrow(alpine_env_nonvasc), control = perm_design_alpine_nonvasc, nset = 999))
          
          #create object for Ss to be stored 
          results39 <- matrix(nrow = nrow(perms39), ncol = 4)
          colnames(results39) <- c("Park", "Plot", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms39)) {
            temp.data <- alpine_env_nonvasc[perms39[i, ], ]
            temp <- adonis2(alpine_env_nonvasc$Species_Richness ~ Park + Plot,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results39[i, ] <- t(temp$SumOfSqs)
          }
          
          #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results39 <- results39 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/14))
          head(results39)
          #first row is observed/your data, rows 2-1000 are the permuted data 
          #calculate P value 
          with(results39, sum(F.Park >= F.Park[1]) / length(F.Park))
          print(alpine_nonvasc_univariate_park)

      #Differences between subclasses 
        #Base Model 
          alpine_nonvasc_univariate_subclass <- adonis2(alpine_env_nonvasc$Species_Richness ~ Viereck.3 + Park + 
                                                 Plot + Sample_Year + Viereck.3*Sample_Year,
                                              data = alpine_env_nonvasc, 
                                              method = "euclidian",
                                              permutations = perm_design_alpine_nonvasc_time,
                                              by = "terms")
          print(alpine_nonvasc_univariate_subclass)
          
          #hand calculate corrected F values
          #create permutation object 
          perms40 <- rbind(1:nrow(alpine_env_nonvasc),
                         shuffleSet(n = nrow(alpine_env_nonvasc), 
                                    control = perm_design_alpine_nonvasc, nset = 999))
          
          #create object for Ss to be stored 
          results40 <- matrix(nrow = nrow(perms40), ncol = 6)
          colnames(results40) <- c("Viereck.3", "Plot", "Sample_Year", 
                                 "Viereck.3*Sample_Year", "Residual", "Total")
          
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
          for (i in 1:nrow(perms40)) {
            temp.data <- alpine_env_nonvasc[perms40[i, ], ]
            temp <- adonis2(alpine_env_nonvasc$Species_Richness ~ Viereck.3 + Park + Plot + 
                              Sample_Year + Viereck.3*Sample_Year,
                            data = temp.data,
                            method = "euclidian",
                            by = "terms",
                            permutations = 0)
            results40[i, ] <- t(temp$SumOfSqs)
          }
          
        #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results40 <- results40 |>
            data.frame() |>
            mutate(F.Park = (Park/1)/(Plot/12))
          head(results40)
          #first row is observed/your data, rows 2-1000 are the permuted data 
          #calculate P value 
          with(results40, sum(F.Park >= F.Park[1]) / length(F.Park))

        #create F value column  - make sure to use the correct Degree of freedom values in the numerator and denominator 
          results40 <- results40 |>
            data.frame() |>
            mutate(F.Viereck = (Viereck.3/4)/(Plot/12))
          head40 <- head(results40)
          print.data.frame(head40)
          #first row is observed/your data, rows 2-1000 are the permuted data 
          #calculate P value 
          with(results40, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

### Multivariate - Species Frequency  

  #Differences between parks 
      #base model 
            alpine_nonvasc_multivariate_park <- adonis2(alpine_nonvasc_composition ~ Park + Plot, 
                                            data = alpine_env_nonvasc, method = "bray", 
                                            permutations = perm_design_alpine_nonvasc, 
                                            by = "terms")
            print(alpine_nonvasc_multivariate_park)
      
            #hand calculate corrected F values
      #create permutation object 
            perms41 <- rbind(1:nrow(alpine_nonvasc_composition),
                            shuffleSet(n = nrow(alpine_nonvasc_composition), control = perm_design_alpine_nonvasc, nset = 999))
            
      #create results object 
            results41 <- matrix(nrow = nrow(perms41), ncol = 4)
            colnames(results41) <- c("Park", "Plot", "Residual", "Total")
            
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
            for (i in 1:nrow(perms41)) {
              temp.data <- alpine_env_nonvasc[perms41[i, ], ]
              temp <- adonis2(alpine_nonvasc_composition ~ Park + Plot,
                              data = temp.data,
                              method = "bray",
                              by = "terms",
                              permutations = 0)
              results41[i, ] <- t(temp$SumOfSqs)
            }
            
      #calculate F values for permutations  - make sure to use the correct Degree of freedom values in the numerator and denominator 
            results41 <- results41 |>
              data.frame() |>
              mutate(F.Park = (Park/1)/(Plot/14))
            head(results41)
      #calculate P value 
            with(results41, sum(F.Park >= F.Park[1]) / length(F.Park))
            print(alpine_nonvasc_multivariate_park)
            
  #Differences among subclasses 
        #base model 
            alpine_nonvasc_multivariate_subclass <- adonis2(alpine_nonvasc_composition ~ Viereck.3 + Park + 
                                               Plot + Sample_Year + Viereck.3*Sample_Year, 
                                            data = alpine_env_nonvasc, method = "bray", 
                                            permutations = perm_design_alpine_nonvasc_time, 
                                            by = "terms")
            alpine_nonvasc_multivariate_subclass
            
            #hand calculate corrected F values
        #create permutation object 
            perms42 <- rbind(1:nrow(alpine_nonvasc_composition),
                            shuffleSet(n = nrow(alpine_nonvasc_composition), 
                                       control = perm_design_alpine_nonvasc, nset = 999))
        #create results object 
            results42 <- matrix(nrow = nrow(perms42), ncol = 6)
            colnames(results42) <- c("Viereck.3",  
                                     "Plot", "Sample_Year", "Viereck.3*Sample_Year", "Residual", "Total")
            
      #loop through running an adonis2 model for each row from perms object (each permutation of the data). this loop puts all of the sums of squares into the results dataframe 
            for (i in 1:nrow(perms42)) {
              temp.data <- alpine_env_nonvasc[perms42[i, ], ]
              temp <- adonis2(alpine_nonvasc_composition ~ Viereck.3 + Park + Plot + 
                                Sample_Year + Viereck.3*Sample_Year,
                              data = temp.data,
                              method = "bray",
                              by = "terms",
                              permutations = 0)
              results42[i, ] <- t(temp$SumOfSqs)
            }
            
        #calculate F values for permutations  - make sure to use the correct Degree of freedom values in the numerator and denominator 
            results42 <- results42 |>
              data.frame() |>
              mutate(F.Park = (Park/1)/(Plot/14))
            head(results42)
        #calculate P value 
            with(results42, sum(F.Park >= F.Park[1]) / length(F.Park))
            print(alpine_nonvasc_multivariate_subclass)

        #calculate F values for permutations  - make sure to use the correct Degree of freedom values in the numerator and denominator 
            results42 <- results42 |>
              data.frame() |>
              mutate(F.Viereck = (Viereck.3/4)/(Plot/14))
            head42 <- head(results42)
            print.data.frame(head42)
        #calculate P value 
            with(results42, sum(F.Viereck >= F.Viereck[1]) / length(F.Viereck))

#Beta Dispersion 

    #based on park 
        alpine_nonvasc_dispersion_result <- betadisper(vegdist(alpine_nonvasc_composition, 
                                                              method = "bray"), alpine_env_nonvasc$Park)
        alpine_nonvasc_dispersion_result 
        permutest(alpine_nonvasc_dispersion_result, permutations = 999)

    #based on visit 
        alpine_nonvasc_dispersion_result2 <- betadisper(vegdist(alpine_nonvasc_composition, 
                                                              method = "bray"), alpine_env_nonvasc$Visit)
        alpine_nonvasc_dispersion_result2 
        permutest(alpine_nonvasc_dispersion_result2, permutations = 999)

    #based on viereck.3
        alpine_nonvasc_dispersion_result3 <- betadisper(vegdist(alpine_nonvasc_composition, 
                                                              method = "bray"), alpine_env_nonvasc$Viereck.3)
        alpine_nonvasc_dispersion_result3 
        permutest(alpine_nonvasc_dispersion_result3, permutations = 999)

```
